
            <script type='text/javascript'>
              {
                function render (node, options) {
                  try {
                    if (typeof node !== 'object') {
                      return
                    }
                    let minWidth = '400px'
                    if (options) {
                      if (options.minWidth) minWidth = options.minWidth
                    }
                    if (!node.__clone) {
                      node.__clone = window.$.extend(true, {}, node)
                    }
                    new Linode({
                      target: document.getElementById('linode-svelte-container'),
                      props: { node: node.__clone }
                    })
                    document.getElementById('linode-svelte-container').style.width = minWidth
                    const nodeIsSidebarTab = node?._def?.onchange
                    if (!nodeIsSidebarTab) {
                      const orgResize = node._def.oneditresize
                      node._def.oneditresize = function (size) {
                        document.getElementById('linode-svelte-container').style.width = 'auto'
                        if (orgResize) orgResize(size)
                        node._def.oneditresize = orgResize
                      }
                    }
                  } catch (e) {
                      console.log(e)
                  }
                }
                function update (node) {
                  if (node.__clone) {
                    const clone = node.__clone
                    delete node.__clone
                    const defaultKeys = Object.keys(node._def.defaults)
                    for (const key of Object.keys(clone)) {
                      if (defaultKeys.indexOf(key) === -1) {
                        delete clone[key]
                      }
                    }
                    Object.assign(node, clone)
                  }
                }
                function revert (node) {
                  delete node.__clone
                }
                function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function get_all_dirty_from_scope($$scope) {
    if ($$scope.ctx.length > 32) {
        const dirty = [];
        const length = $$scope.ctx.length / 32;
        for (let i = 0; i < length; i++) {
            dirty[i] = -1;
        }
        return dirty;
    }
    return -1;
}
function null_to_empty(value) {
    return value == null ? '' : value;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}
function append(target, node) {
    target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
    const append_styles_to = get_root_for_style(target);
    if (!append_styles_to.getElementById(style_sheet_id)) {
        const style = element('style');
        style.id = style_sheet_id;
        style.textContent = styles;
        append_stylesheet(append_styles_to, style);
    }
}
function get_root_for_style(node) {
    if (!node)
        return document;
    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
    if (root && root.host) {
        return root;
    }
    return node.ownerDocument;
}
function append_empty_stylesheet(node) {
    const style_element = element('style');
    append_stylesheet(get_root_for_style(node), style_element);
    return style_element;
}
function append_stylesheet(node, style) {
    append(node.head || node, style);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function to_number(value) {
    return value === '' ? null : +value;
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
    select.selectedIndex = -1; // no option should be selected
}
function select_value(select) {
    const selected_option = select.querySelector(':checked') || select.options[0];
    return selected_option && selected_option.__value;
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail, bubbles = false) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, bubbles, false, detail);
    return e;
}

const active_docs = new Set();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = get_root_for_style(node);
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        active_docs.forEach(doc => {
            const stylesheet = doc.__svelte_stylesheet;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            doc.__svelte_rules = {};
        });
        active_docs.clear();
    });
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        // @ts-ignore
        callbacks.slice().forEach(fn => fn.call(this, event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update$1(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update$1($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
    let config = fn(node, params);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function init(program, duration) {
        const d = (program.b - t);
        duration *= Math.abs(d);
        return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group
        };
    }
    function go(b) {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        const program = {
            start: now() + delay,
            b
        };
        if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
        }
        if (running_program || pending_program) {
            pending_program = program;
        }
        else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
                clear_animation();
                animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b)
                tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, 'start'));
            loop(now => {
                if (pending_program && now > pending_program.start) {
                    running_program = init(pending_program, duration);
                    pending_program = null;
                    dispatch(node, running_program.b, 'start');
                    if (css) {
                        clear_animation();
                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                    }
                }
                if (running_program) {
                    if (now >= running_program.end) {
                        tick(t = running_program.b, 1 - t);
                        dispatch(node, running_program.b, 'end');
                        if (!pending_program) {
                            // we're done
                            if (running_program.b) {
                                // intro — we can tidy up immediately
                                clear_animation();
                            }
                            else {
                                // outro — needs to be coordinated
                                if (!--running_program.group.r)
                                    run_all(running_program.group.c);
                            }
                        }
                        running_program = null;
                    }
                    else if (now >= running_program.start) {
                        const p = now - running_program.start;
                        t = running_program.a + running_program.d * easing(p / running_program.duration);
                        tick(t, 1 - t);
                    }
                }
                return !!(running_program || pending_program);
            });
        }
    }
    return {
        run(b) {
            if (is_function(config)) {
                wait().then(() => {
                    // @ts-ignore
                    config = config();
                    go(b);
                });
            }
            else {
                go(b);
            }
        },
        end() {
            clear_animation();
            running_program = pending_program = null;
        }
    };
}

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
    }
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : options.context || []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false,
        root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance
        ? instance(component, options.props || {}, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor, options.customElement);
        flush();
    }
    set_current_component(parent_component);
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

const getBooleanFrom = (property) => {
  return typeof property === 'boolean' ? property : property.toString().toLowerCase() === 'true'
};

const getId = (prop = null) => {
  let id = prop;
  if (!id) {
    id = Date.now() + Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
  }
  return id
};

function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}

/* ../svelte-integration-red/components/Row.svelte generated by Svelte v3.42.4 */

function add_css$9(target) {
	append_styles(target, "svelte-z33cig", ".sir-form-row.svelte-z33cig{clear:both;color:#555;margin-bottom:12px;display:flex;align-items:center;justify-content:flex-start}.sir-form-row > *:not(:last-child){margin-right:7px}.sir-form-row.inline button:not(:last-child){margin-right:3px}.sir-form-row label{display:inline-block;min-width:105px;width:105px;margin-right:7px;align-items:center;margin-bottom:0px;overflow-wrap:break-word}#red-ui-sidebar-content .sir-form-row :is(input, select, textarea){margin-bottom:0px}.red-ui-editor .sir-form-row input{height:auto}");
}

// (47:2) {#if indented}
function create_if_block$9(ctx) {
	let label;

	return {
		c() {
			label = element("label");
		},
		m(target, anchor) {
			insert(target, label, anchor);
		},
		d(detaching) {
			if (detaching) detach(label);
		}
	};
}

function create_fragment$a(ctx) {
	let div;
	let t;
	let div_class_value;
	let div_transition;
	let current;
	let if_block = /*indented*/ ctx[1] && create_if_block$9();
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			attr(div, "class", div_class_value = "" + (null_to_empty(/*clazz*/ ctx[2]) + " svelte-z33cig"));
			attr(div, "style", /*style*/ ctx[3]);
			toggle_class(div, "sir-form-row", !/*inline*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (/*indented*/ ctx[1]) {
				if (if_block) ; else {
					if_block = create_if_block$9();
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*clazz*/ 4 && div_class_value !== (div_class_value = "" + (null_to_empty(/*clazz*/ ctx[2]) + " svelte-z33cig"))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 8) {
				attr(div, "style", /*style*/ ctx[3]);
			}

			if (dirty & /*clazz, inline*/ 5) {
				toggle_class(div, "sir-form-row", !/*inline*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: /*fadeDuration*/ ctx[4] }, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: /*fadeDuration*/ ctx[4] }, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			if (detaching && div_transition) div_transition.end();
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { clazz = '', style, inline = false, maximize = false, indented = false, fading = true } = $$props;
	inline = getBooleanFrom(inline);
	maximize = getBooleanFrom(maximize);
	indented = getBooleanFrom(indented);
	let fadeDuration = 400;

	// do not use isNaN with boolean!
	if (typeof fading === 'number') {
		fadeDuration = fading;
	} else {
		fading = getBooleanFrom(fading);
		if (!fading) fadeDuration = 0;
	}

	$$self.$$set = $$props => {
		if ('clazz' in $$props) $$invalidate(2, clazz = $$props.clazz);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
		if ('inline' in $$props) $$invalidate(0, inline = $$props.inline);
		if ('maximize' in $$props) $$invalidate(5, maximize = $$props.maximize);
		if ('indented' in $$props) $$invalidate(1, indented = $$props.indented);
		if ('fading' in $$props) $$invalidate(6, fading = $$props.fading);
		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	return [inline, indented, clazz, style, fadeDuration, maximize, fading, $$scope, slots];
}

class Row extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$a,
			create_fragment$a,
			safe_not_equal,
			{
				clazz: 2,
				style: 3,
				inline: 0,
				maximize: 5,
				indented: 1,
				fading: 6
			},
			add_css$9
		);
	}
}

/* global localStorage, */

// Translation:
// current way with Node-RED tools:
// - an i18nOptions object for the node where we can set a prefix if the Node-Red node is not in the main folder.
// - to translate in a SIR component object just set the node property and set the path within the json file, e.g.: label:{ label.name }.
// - instead of giving the node property you can set an i18n property with the path to the local folder, e.g.: 'test-node/second-node:' or if in the main folder: 'second-node:'
//
// a different approach to the code below is to use the offical way like:
// - direct i18n in html <span data-i18n="test-node/second-node:second-node.label.name"></span>
// - setting to placeholder prop <input type="text" data-i18n="[placeholder]myNode.placeholder.foo">
//
// Sidenote: This translation is only working for custom nodes. Translations for the sir components are within their files.
// This must be done that way, as we must ensure translation, whether SIR is installed or not. Also it seems that Node-Red only initialize translation files
// for nodes registered in the package.json.
// Addition: Since Node-Red 2.0.3 we can't import i18next as this will break all other translations.

localStorage.getItem('editor-language') || navigator.language || 'en-US';

const i18nTranslate = (RED, node = {}, i18nDOM = true, translateThis) => {
  let result = translateThis;
  // i18n can be a string for the local folder path (which we can't have without node) or boolean false if we don't want to translate this one
  if (i18nDOM === false || i18nDOM.toString().trim() === 'false') {
    return result
  }

  let path = '';
  if (typeof i18nDOM === 'string') {
    path = i18nDOM;
  } else if (node) {
    path = node.type;
    let folder = node?._def?.i18nOptions?.folder;
    if (folder) {
      if (!folder.endsWith('/')) {
        folder += '/';
      }
      path = folder + path;
    }
  }
  if (path) {
    if (!path.endsWith(':')) path += ':';
    result = RED._(path + translateThis);
    // RED._() will replace colon with dot, so we have to check if result is like that pattern
    const translateColonReplacedWithDot = translateThis.replaceAll(':', '.');
    if (result === path + translateThis || result === path + translateColonReplacedWithDot || result === translateColonReplacedWithDot) {
      // couldn't find translation
      result = translateThis;
    }
  }
  return result
};

/* ../svelte-integration-red/components/PlainInput.svelte generated by Svelte v3.42.4 */

function add_css$8(target) {
	append_styles(target, "svelte-1idal5v", ".maximize.svelte-1idal5v{width:100%}.label.svelte-1idal5v{min-width:100px;margin-bottom:5px}");
}

// (109:0) {:else}
function create_else_block_1$1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: No property name given.";
			attr(span, "class", "maximize svelte-1idal5v");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (80:0) {#if !updateNode || prop}
function create_if_block$8(ctx) {
	let t;
	let if_block1_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[3] !== 'checkbox' && /*label*/ ctx[1] || /*type*/ ctx[3] === 'checkbox' && /*label*/ ctx[1] && /*labelBeforeCheckbox*/ ctx[6]) return create_if_block_9;
		if (/*indented*/ ctx[5]) return create_if_block_11;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block0 = current_block_type && current_block_type(ctx);

	function select_block_type_2(ctx, dirty) {
		if (/*type*/ ctx[3] === 'text') return create_if_block_1$7;
		if (/*type*/ ctx[3] === 'number') return create_if_block_2$4;
		if (/*type*/ ctx[3] === 'password') return create_if_block_3$4;
		if (/*type*/ ctx[3] === 'email') return create_if_block_4$4;
		if (/*type*/ ctx[3] === 'url') return create_if_block_5$3;
		if (/*type*/ ctx[3] === 'checkbox') return create_if_block_6;
		return create_else_block$5;
	}

	let current_block_type_1 = select_block_type_2(ctx);
	let if_block1 = current_block_type_1(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space();
			if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t, anchor);
			if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			}
		},
		d(detaching) {
			if (if_block0) {
				if_block0.d(detaching);
			}

			if (detaching) detach(t);
			if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

// (85:21) 
function create_if_block_11(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (81:2) {#if (type !== 'checkbox' && label) || (type === 'checkbox' && label && labelBeforeCheckbox)}
function create_if_block_9(ctx) {
	let label_1;
	let t0;
	let t1;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[4] && create_if_block_10(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[1]);
			attr(label_1, "for", /*inputId*/ ctx[12]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler*/ ctx[33]),
					listen(label_1, "mouseleave", /*mouseleave_handler*/ ctx[34])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_10(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*label*/ 2) set_data(t1, /*label*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (83:6) {#if icon}
function create_if_block_10(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1idal5v");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 16 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1idal5v")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (106:2) {:else}
function create_else_block$5(ctx) {
	let span;
	let t0;
	let t1;
	let t2;

	return {
		c() {
			span = element("span");
			t0 = text("Error: Unsupported property type '");
			t1 = text(/*type*/ ctx[3]);
			t2 = text("'.");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			append(span, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*type*/ 8) set_data(t1, /*type*/ ctx[3]);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (99:32) 
function create_if_block_6(ctx) {
	let div;
	let input;
	let t;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[1] && !/*labelBeforeCheckbox*/ ctx[6] && create_if_block_7(ctx);

	return {
		c() {
			div = element("div");
			input = element("input");
			t = space();
			if (if_block) if_block.c();
			attr(input, "type", "checkbox");
			attr(input, "id", /*inputId*/ ctx[12]);
			input.disabled = /*disabled*/ ctx[7];
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			attr(div, "class", "checkbox");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, input);
			input.checked = /*value*/ ctx[0];
			append(div, t);
			if (if_block) if_block.m(div, null);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_6*/ ctx[31]),
					listen(input, "mouseleave", /*mouseleave_handler_6*/ ctx[32]),
					listen(input, "change", /*input_change_handler*/ ctx[40])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*disabled*/ 128) {
				input.disabled = /*disabled*/ ctx[7];
			}

			if (dirty[0] & /*value*/ 1) {
				input.checked = /*value*/ ctx[0];
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}

			if (/*label*/ ctx[1] && !/*labelBeforeCheckbox*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_7(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (97:27) 
function create_if_block_5$3(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[7];
			attr(input, "type", "url");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_5*/ ctx[27]),
					listen(input, "mouseleave", /*mouseleave_handler_5*/ ctx[28]),
					listen(input, "input", /*input_input_handler_4*/ ctx[39])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 128) {
				input.disabled = /*disabled*/ ctx[7];
			}

			if (dirty[0] & /*value*/ 1) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*maximize*/ 512) {
				toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (95:29) 
function create_if_block_4$4(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[7];
			attr(input, "type", "email");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_4*/ ctx[25]),
					listen(input, "mouseleave", /*mouseleave_handler_4*/ ctx[26]),
					listen(input, "input", /*input_input_handler_3*/ ctx[38])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 128) {
				input.disabled = /*disabled*/ ctx[7];
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*maximize*/ 512) {
				toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (93:32) 
function create_if_block_3$4(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[7];
			attr(input, "type", "password");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_3*/ ctx[23]),
					listen(input, "mouseleave", /*mouseleave_handler_3*/ ctx[24]),
					listen(input, "input", /*input_input_handler_2*/ ctx[37])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 128) {
				input.disabled = /*disabled*/ ctx[7];
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*maximize*/ 512) {
				toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (91:30) 
function create_if_block_2$4(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[7];
			attr(input, "type", "number");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_2*/ ctx[21]),
					listen(input, "mouseleave", /*mouseleave_handler_2*/ ctx[22]),
					listen(input, "input", /*input_input_handler_1*/ ctx[36])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 128) {
				input.disabled = /*disabled*/ ctx[7];
			}

			if (dirty[0] & /*value*/ 1 && to_number(input.value) !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*maximize*/ 512) {
				toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (89:2) {#if type === 'text'}
function create_if_block_1$7(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*inputId*/ ctx[12]);
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[7];
			attr(input, "type", "text");
			attr(input, "class", "svelte-1idal5v");
			toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "mouseenter", /*mouseenter_handler_1*/ ctx[19]),
					listen(input, "mouseleave", /*mouseleave_handler_1*/ ctx[20]),
					listen(input, "input", /*input_input_handler*/ ctx[35])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 128) {
				input.disabled = /*disabled*/ ctx[7];
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*maximize*/ 512) {
				toggle_class(input, "maximize", /*maximize*/ ctx[9]);
			}

			if (dirty[0] & /*isValid*/ 1024) {
				toggle_class(input, "input-error", !/*isValid*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) detach(input);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (102:8) {#if label && !labelBeforeCheckbox}
function create_if_block_7(ctx) {
	let label_1;
	let t0;
	let t1;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[4] && create_if_block_8(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[1]);
			attr(label_1, "for", /*inputId*/ ctx[12]);
			set_style(label_1, "width", "100%");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler_7*/ ctx[29]),
					listen(label_1, "mouseleave", /*mouseleave_handler_7*/ ctx[30])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_8(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*label*/ 2) set_data(t1, /*label*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (103:79) {#if icon}
function create_if_block_8(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1idal5v");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 16 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[4] + " svelte-1idal5v")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

function create_fragment$9(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (!/*updateNode*/ ctx[11] || /*prop*/ ctx[8]) return create_if_block$8;
		return create_else_block_1$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let { node, prop, value, type, icon, credentials = false, indented = false, label, labelBeforeCheckbox = false, placeholder, maximize, id, disabled = false, i18n } = $$props;

	if (!id) {
		id = getId(prop);
	}

	credentials = getBooleanFrom(credentials);
	indented = getBooleanFrom(indented);
	disabled = getBooleanFrom(disabled);
	labelBeforeCheckbox = getBooleanFrom(labelBeforeCheckbox);
	let defaults;

	if (!node) {
		defaults = {};
	} else {
		defaults = credentials ? node._def.credentials : node._def.defaults;
	}

	const dispatch = createEventDispatcher();
	const updateNode = typeof node !== 'undefined';
	value = updateNode && node[prop] || value;
	let isValid = true;
	let init = true;
	icon = icon || defaults?.[prop]?.icon || '';

	if (label !== false) {
		label = label || defaults?.[prop]?.label || prop || '';
	}

	placeholder = placeholder || defaults?.[prop]?.placeholder || '';

	if (!type) {
		let testValue = defaults[prop] ? defaults[prop].value : value;

		if (typeof testValue === 'number') {
			type = 'number';
		} else if (typeof testValue === 'boolean') {
			type = 'checkbox';
		} else {
			type = 'text';
		}
	}

	let inputId = 'node-input-' + id;

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_4(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_5(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_7(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_6(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_input_handler_1() {
		value = to_number(this.value);
		$$invalidate(0, value);
	}

	function input_input_handler_2() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_input_handler_3() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_input_handler_4() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_change_handler() {
		value = this.checked;
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(13, node = $$props.node);
		if ('prop' in $$props) $$invalidate(8, prop = $$props.prop);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('type' in $$props) $$invalidate(3, type = $$props.type);
		if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
		if ('credentials' in $$props) $$invalidate(15, credentials = $$props.credentials);
		if ('indented' in $$props) $$invalidate(5, indented = $$props.indented);
		if ('label' in $$props) $$invalidate(1, label = $$props.label);
		if ('labelBeforeCheckbox' in $$props) $$invalidate(6, labelBeforeCheckbox = $$props.labelBeforeCheckbox);
		if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
		if ('maximize' in $$props) $$invalidate(9, maximize = $$props.maximize);
		if ('id' in $$props) $$invalidate(14, id = $$props.id);
		if ('disabled' in $$props) $$invalidate(7, disabled = $$props.disabled);
		if ('i18n' in $$props) $$invalidate(16, i18n = $$props.i18n);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*defaults, prop, value, init, id*/ 409857) {
			{
				if (defaults?.[prop]?.validate) {
					$$invalidate(10, isValid = defaults?.[prop]?.validate(value));
				}

				if (updateNode) {
					$$invalidate(13, node[prop] = value, node);
				}

				if (!init) {
					dispatch('change', { id, value });
				}

				$$invalidate(18, init = false);
			}
		}

		if ($$self.$$.dirty[0] & /*label, node, i18n*/ 73730) {
			{
				if (label) {
					$$invalidate(1, label = i18nTranslate(RED, node, i18n, label));
				}
			}
		}

		if ($$self.$$.dirty[0] & /*placeholder, node, i18n*/ 73732) {
			{
				if (placeholder) {
					$$invalidate(2, placeholder = i18nTranslate(RED, node, i18n, placeholder));
				}
			}
		}
	};

	return [
		value,
		label,
		placeholder,
		type,
		icon,
		indented,
		labelBeforeCheckbox,
		disabled,
		prop,
		maximize,
		isValid,
		updateNode,
		inputId,
		node,
		id,
		credentials,
		i18n,
		defaults,
		init,
		mouseenter_handler_1,
		mouseleave_handler_1,
		mouseenter_handler_2,
		mouseleave_handler_2,
		mouseenter_handler_3,
		mouseleave_handler_3,
		mouseenter_handler_4,
		mouseleave_handler_4,
		mouseenter_handler_5,
		mouseleave_handler_5,
		mouseenter_handler_7,
		mouseleave_handler_7,
		mouseenter_handler_6,
		mouseleave_handler_6,
		mouseenter_handler,
		mouseleave_handler,
		input_input_handler,
		input_input_handler_1,
		input_input_handler_2,
		input_input_handler_3,
		input_input_handler_4,
		input_change_handler
	];
}

class PlainInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$9,
			create_fragment$9,
			safe_not_equal,
			{
				node: 13,
				prop: 8,
				value: 0,
				type: 3,
				icon: 4,
				credentials: 15,
				indented: 5,
				label: 1,
				labelBeforeCheckbox: 6,
				placeholder: 2,
				maximize: 9,
				id: 14,
				disabled: 7,
				i18n: 16
			},
			add_css$8,
			[-1, -1]
		);
	}
}

/* ../svelte-integration-red/components/Button.svelte generated by Svelte v3.42.4 */

function add_css$7(target) {
	append_styles(target, "svelte-1dv5lek", ".sir-button.svelte-1dv5lek{width:fit-content}.minWidth.svelte-1dv5lek{min-width:33px}.red-ui-button-small.svelte-1dv5lek{min-width:21px}button.red-ui-button.sir-button:not(.primary):not(.disabled):not(:disabled):hover{background:#e0e0e0}.maximize.svelte-1dv5lek{width:100%}");
}

// (44:2) {#if indented}
function create_if_block_1$6(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (50:4) {#if icon}
function create_if_block$7(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[7] + " svelte-1dv5lek");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 128 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[7] + " svelte-1dv5lek")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (43:0) <Row {inline} {fading}>
function create_default_slot$6(ctx) {
	let t0;
	let button;
	let t1;
	let t2_value = (/*label*/ ctx[0] || '') + "";
	let t2;
	let mounted;
	let dispose;
	let if_block0 = /*indented*/ ctx[6] && create_if_block_1$6();
	let if_block1 = /*icon*/ ctx[7] && create_if_block$7(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			button = element("button");
			if (if_block1) if_block1.c();
			t1 = space();
			t2 = text(t2_value);
			attr(button, "id", /*id*/ ctx[1]);
			attr(button, "style", /*style*/ ctx[9]);
			button.disabled = /*disabled*/ ctx[3];
			attr(button, "type", "button");
			attr(button, "class", "red-ui-button sir-button svelte-1dv5lek");
			toggle_class(button, "maximize", /*maximize*/ ctx[4]);
			toggle_class(button, "selected", /*selected*/ ctx[10]);
			toggle_class(button, "red-ui-button-small", /*small*/ ctx[2]);
			toggle_class(button, "primary", /*primary*/ ctx[8] && !/*disabled*/ ctx[3]);
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, button, anchor);
			if (if_block1) if_block1.m(button, null);
			append(button, t1);
			append(button, t2);

			if (!mounted) {
				dispose = listen(button, "click", /*clickHandler*/ ctx[12]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*indented*/ ctx[6]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_1$6();
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*icon*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$7(ctx);
					if_block1.c();
					if_block1.m(button, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*label*/ 1 && t2_value !== (t2_value = (/*label*/ ctx[0] || '') + "")) set_data(t2, t2_value);

			if (dirty & /*id*/ 2) {
				attr(button, "id", /*id*/ ctx[1]);
			}

			if (dirty & /*style*/ 512) {
				attr(button, "style", /*style*/ ctx[9]);
			}

			if (dirty & /*disabled*/ 8) {
				button.disabled = /*disabled*/ ctx[3];
			}

			if (dirty & /*maximize*/ 16) {
				toggle_class(button, "maximize", /*maximize*/ ctx[4]);
			}

			if (dirty & /*selected*/ 1024) {
				toggle_class(button, "selected", /*selected*/ ctx[10]);
			}

			if (dirty & /*small*/ 4) {
				toggle_class(button, "red-ui-button-small", /*small*/ ctx[2]);
			}

			if (dirty & /*primary, disabled*/ 264) {
				toggle_class(button, "primary", /*primary*/ ctx[8] && !/*disabled*/ ctx[3]);
			}
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(button);
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$8(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				inline: /*inline*/ ctx[5],
				fading: /*fading*/ ctx[11],
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*inline*/ 32) row_changes.inline = /*inline*/ ctx[5];
			if (dirty & /*fading*/ 2048) row_changes.fading = /*fading*/ ctx[11];

			if (dirty & /*$$scope, id, style, disabled, maximize, selected, small, primary, label, icon, indented*/ 67551) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let { node, id, icon, label, small = false, disabled = false, primary = false, style, selected = false, maximize = false, inline = false, indented = false, fading = true, i18n } = $$props;
	small = getBooleanFrom(small);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	inline = getBooleanFrom(inline);
	indented = getBooleanFrom(indented);

	if (!id) {
		id = getId();
	}

	if (label) label = i18nTranslate(RED, node, i18n, label);
	const dispatch = createEventDispatcher();

	function clickHandler(event) {
		dispatch('click', event.details);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(13, node = $$props.node);
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('icon' in $$props) $$invalidate(7, icon = $$props.icon);
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('small' in $$props) $$invalidate(2, small = $$props.small);
		if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ('primary' in $$props) $$invalidate(8, primary = $$props.primary);
		if ('style' in $$props) $$invalidate(9, style = $$props.style);
		if ('selected' in $$props) $$invalidate(10, selected = $$props.selected);
		if ('maximize' in $$props) $$invalidate(4, maximize = $$props.maximize);
		if ('inline' in $$props) $$invalidate(5, inline = $$props.inline);
		if ('indented' in $$props) $$invalidate(6, indented = $$props.indented);
		if ('fading' in $$props) $$invalidate(11, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(14, i18n = $$props.i18n);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*label, node, i18n*/ 24577) {
			{
				if (label) {
					$$invalidate(0, label = i18nTranslate(RED, node, i18n, label));
				}
			}
		}
	};

	return [
		label,
		id,
		small,
		disabled,
		maximize,
		inline,
		indented,
		icon,
		primary,
		style,
		selected,
		fading,
		clickHandler,
		node,
		i18n
	];
}

class Button extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$8,
			create_fragment$8,
			safe_not_equal,
			{
				node: 13,
				id: 1,
				icon: 7,
				label: 0,
				small: 2,
				disabled: 3,
				primary: 8,
				style: 9,
				selected: 10,
				maximize: 4,
				inline: 5,
				indented: 6,
				fading: 11,
				i18n: 14
			},
			add_css$7
		);
	}
}

/* ../svelte-integration-red/components/ConfigNodeInput.svelte generated by Svelte v3.42.4 */

function add_css$6(target) {
	append_styles(target, "svelte-1grox8e", ".disabled.svelte-1grox8e{pointer-events:none}.maximize.svelte-1grox8e{width:100%}");
}

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i].id;
	child_ctx[3] = list[i].label;
	return child_ctx;
}

// (105:0) {:else}
function create_else_block$4(ctx) {
	let span;
	let t0;
	let t1;

	return {
		c() {
			span = element("span");
			t0 = text("Error: ");
			t1 = text(/*error*/ ctx[8]);
			attr(span, "class", "maximize svelte-1grox8e");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*error*/ 256) set_data(t1, /*error*/ ctx[8]);
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (95:0) {#if node && prop}
function create_if_block$6(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let t2;
	let select;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let select_id_value;
	let select_placeholder_value;
	let t3;
	let button;
	let current;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[6] && create_if_block_1$5(ctx);
	let each_value = /*configNodes*/ ctx[9];
	const get_key = ctx => /*id*/ ctx[4];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	}

	button = new Button({
			props: {
				id: "node-input-lookup-" + /*prop*/ ctx[5],
				inline: true,
				disabled: /*disabled*/ ctx[1],
				icon: "pencil"
			}
		});

	button.$on("click", /*editConfigNode*/ ctx[11]);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[3]);
			t2 = space();
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			create_component(button.$$.fragment);
			attr(label_1, "for", label_1_for_value = "node-input-" + /*prop*/ ctx[5]);
			attr(select, "id", select_id_value = "node-input-" + /*prop*/ ctx[5]);
			attr(select, "placeholder", select_placeholder_value = /*defaults*/ ctx[10][/*prop*/ ctx[5]].label);
			select.disabled = /*disabled*/ ctx[1];
			attr(select, "class", "svelte-1grox8e");
			if (/*selectedNode*/ ctx[7] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[16].call(select));
			toggle_class(select, "input-error", /*selectedNode*/ ctx[7] === '_ADD_');
			toggle_class(select, "maximize", /*maximize*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);
			insert(target, t2, anchor);
			insert(target, select, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*selectedNode*/ ctx[7]);
			insert(target, t3, anchor);
			mount_component(button, target, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[16]),
					listen(select, "mouseenter", /*mouseenter_handler*/ ctx[14]),
					listen(select, "mouseleave", /*mouseleave_handler*/ ctx[15])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$5(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty & /*label*/ 8) set_data(t1, /*label*/ ctx[3]);

			if (!current || dirty & /*prop*/ 32 && label_1_for_value !== (label_1_for_value = "node-input-" + /*prop*/ ctx[5])) {
				attr(label_1, "for", label_1_for_value);
			}

			if (dirty & /*configNodes*/ 512) {
				each_value = /*configNodes*/ ctx[9];
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block$3, null, get_each_context$3);
			}

			if (!current || dirty & /*prop*/ 32 && select_id_value !== (select_id_value = "node-input-" + /*prop*/ ctx[5])) {
				attr(select, "id", select_id_value);
			}

			if (!current || dirty & /*prop*/ 32 && select_placeholder_value !== (select_placeholder_value = /*defaults*/ ctx[10][/*prop*/ ctx[5]].label)) {
				attr(select, "placeholder", select_placeholder_value);
			}

			if (!current || dirty & /*disabled*/ 2) {
				select.disabled = /*disabled*/ ctx[1];
			}

			if (dirty & /*selectedNode, configNodes*/ 640) {
				select_option(select, /*selectedNode*/ ctx[7]);
			}

			if (dirty & /*selectedNode*/ 128) {
				toggle_class(select, "input-error", /*selectedNode*/ ctx[7] === '_ADD_');
			}

			if (dirty & /*maximize*/ 4) {
				toggle_class(select, "maximize", /*maximize*/ ctx[2]);
			}

			const button_changes = {};
			if (dirty & /*prop*/ 32) button_changes.id = "node-input-lookup-" + /*prop*/ ctx[5];
			if (dirty & /*disabled*/ 2) button_changes.disabled = /*disabled*/ ctx[1];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			if (detaching) detach(t2);
			if (detaching) detach(select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach(t3);
			destroy_component(button, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (96:33) {#if icon}
function create_if_block_1$5(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[6] + " svelte-1grox8e");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 64 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[6] + " svelte-1grox8e")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (100:6) {#each configNodes as { id, label }
function create_each_block$3(key_1, ctx) {
	let option;
	let t_value = /*label*/ ctx[3] + "";
	let t;
	let option_value_value;

	return {
		key: key_1,
		first: null,
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*id*/ ctx[4];
			option.value = option.__value;
			this.first = option;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*configNodes*/ 512 && t_value !== (t_value = /*label*/ ctx[3] + "")) set_data(t, t_value);

			if (dirty & /*configNodes*/ 512 && option_value_value !== (option_value_value = /*id*/ ctx[4])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

function create_fragment$7(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$6, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*node*/ ctx[0] && /*prop*/ ctx[5]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let { node, prop, icon, label, id, disabled = false, maximize = true, i18n } = $$props;

	if (!id) {
		id = getId(prop);
	}

	let error = '';
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);

	if (!node) {
		node = {};
		error = "No node property given.";
	} else if (!prop) {
		error = "No property name given.";
	}

	const dispatch = createEventDispatcher();
	let defaults = node._def.defaults;
	label = label || defaults[prop] && defaults[prop].label || prop;
	if (label) label = i18nTranslate(RED, node, i18n, label);
	let configNodes = [];
	let previouslySelectedNode = node[prop] || '_ADD_';
	let selectedNode = node[prop] || '_ADD_';

	function updateConfigNodes() {
		$$invalidate(9, configNodes = []);
		const type = defaults[prop].type;
		const node_def = RED.nodes.getType(type);

		RED.nodes.eachConfig(function (config) {
			if (config.type === type) {
				let label = '';

				if (typeof node_def.label === 'function') {
					label = node_def.label.call(config);
				} else {
					label = node_def.label;
				}

				configNodes.push({ id: config.id, label });
			}
		});

		$$invalidate(9, configNodes = [...configNodes, { id: '_ADD_', label: `Add new ${type}...` }]);
	}

	onMount(() => {
		updateConfigNodes();

		RED.events.on('nodes:add', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();
				$$invalidate(7, selectedNode = e.id);
			}
		});

		RED.events.on('nodes:change', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();
			}
		});

		RED.events.on('nodes:remove', e => {
			if (e.type === defaults[prop].type) {
				updateConfigNodes();

				// Always select '_ADD_' after deleting (standard behaviour)
				// otherwise it breaks the node if only one other option was available
				$$invalidate(7, selectedNode = '_ADD_');
			}
		});
	});

	function editConfigNode() {
		// The prefix is omitted so the select gets updated by us and not by Node-RED
		RED.editor.editConfig(prop, defaults[prop].type, selectedNode); /*, 'node-input' */
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function select_change_handler() {
		selectedNode = select_value(this);
		$$invalidate(7, selectedNode);
		$$invalidate(9, configNodes);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
		if ('prop' in $$props) $$invalidate(5, prop = $$props.prop);
		if ('icon' in $$props) $$invalidate(6, icon = $$props.icon);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('id' in $$props) $$invalidate(4, id = $$props.id);
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('maximize' in $$props) $$invalidate(2, maximize = $$props.maximize);
		if ('i18n' in $$props) $$invalidate(12, i18n = $$props.i18n);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*selectedNode, previouslySelectedNode, prop*/ 8352) {
			{
				if (selectedNode !== previouslySelectedNode) {
					$$invalidate(0, node[prop] = selectedNode, node);

					dispatch('change', {
						before: previouslySelectedNode,
						after: selectedNode
					});

					$$invalidate(13, previouslySelectedNode = selectedNode);
				}
			}
		}
	};

	return [
		node,
		disabled,
		maximize,
		label,
		id,
		prop,
		icon,
		selectedNode,
		error,
		configNodes,
		defaults,
		editConfigNode,
		i18n,
		previouslySelectedNode,
		mouseenter_handler,
		mouseleave_handler,
		select_change_handler
	];
}

class ConfigNodeInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$7,
			create_fragment$7,
			safe_not_equal,
			{
				node: 0,
				prop: 5,
				icon: 6,
				label: 3,
				id: 4,
				disabled: 1,
				maximize: 2,
				i18n: 12
			},
			add_css$6
		);
	}
}

/* ../svelte-integration-red/components/Input.svelte generated by Svelte v3.42.4 */

function add_css$5(target) {
	append_styles(target, "svelte-1owxzix", ".sir-input{display:inline-flex;align-items:center;width:100%}");
}

// (42:2) {:else}
function create_else_block$3(ctx) {
	let plaininput;
	let updating_node;
	let updating_prop;
	let updating_icon;
	let updating_label;
	let updating_disabled;
	let updating_value;
	let updating_type;
	let updating_placeholder;
	let updating_maximize;
	let current;

	function plaininput_node_binding(value) {
		/*plaininput_node_binding*/ ctx[23](value);
	}

	function plaininput_prop_binding(value) {
		/*plaininput_prop_binding*/ ctx[24](value);
	}

	function plaininput_icon_binding(value) {
		/*plaininput_icon_binding*/ ctx[25](value);
	}

	function plaininput_label_binding(value) {
		/*plaininput_label_binding*/ ctx[26](value);
	}

	function plaininput_disabled_binding(value) {
		/*plaininput_disabled_binding*/ ctx[27](value);
	}

	function plaininput_value_binding(value) {
		/*plaininput_value_binding*/ ctx[28](value);
	}

	function plaininput_type_binding(value) {
		/*plaininput_type_binding*/ ctx[29](value);
	}

	function plaininput_placeholder_binding(value) {
		/*plaininput_placeholder_binding*/ ctx[30](value);
	}

	function plaininput_maximize_binding(value) {
		/*plaininput_maximize_binding*/ ctx[31](value);
	}

	let plaininput_props = {
		i18n: /*i18n*/ ctx[14],
		indented: /*indented*/ ctx[9],
		credentials: /*credentials*/ ctx[11],
		id: /*id*/ ctx[12]
	};

	if (/*node*/ ctx[2] !== void 0) {
		plaininput_props.node = /*node*/ ctx[2];
	}

	if (/*prop*/ ctx[3] !== void 0) {
		plaininput_props.prop = /*prop*/ ctx[3];
	}

	if (/*icon*/ ctx[4] !== void 0) {
		plaininput_props.icon = /*icon*/ ctx[4];
	}

	if (/*label*/ ctx[5] !== void 0) {
		plaininput_props.label = /*label*/ ctx[5];
	}

	if (/*disabled*/ ctx[10] !== void 0) {
		plaininput_props.disabled = /*disabled*/ ctx[10];
	}

	if (/*value*/ ctx[0] !== void 0) {
		plaininput_props.value = /*value*/ ctx[0];
	}

	if (/*type*/ ctx[1] !== void 0) {
		plaininput_props.type = /*type*/ ctx[1];
	}

	if (/*placeholder*/ ctx[6] !== void 0) {
		plaininput_props.placeholder = /*placeholder*/ ctx[6];
	}

	if (/*maximize*/ ctx[8] !== void 0) {
		plaininput_props.maximize = /*maximize*/ ctx[8];
	}

	plaininput = new PlainInput({ props: plaininput_props });
	binding_callbacks.push(() => bind(plaininput, 'node', plaininput_node_binding));
	binding_callbacks.push(() => bind(plaininput, 'prop', plaininput_prop_binding));
	binding_callbacks.push(() => bind(plaininput, 'icon', plaininput_icon_binding));
	binding_callbacks.push(() => bind(plaininput, 'label', plaininput_label_binding));
	binding_callbacks.push(() => bind(plaininput, 'disabled', plaininput_disabled_binding));
	binding_callbacks.push(() => bind(plaininput, 'value', plaininput_value_binding));
	binding_callbacks.push(() => bind(plaininput, 'type', plaininput_type_binding));
	binding_callbacks.push(() => bind(plaininput, 'placeholder', plaininput_placeholder_binding));
	binding_callbacks.push(() => bind(plaininput, 'maximize', plaininput_maximize_binding));
	plaininput.$on("change", /*change_handler_1*/ ctx[32]);
	plaininput.$on("mouseenter", /*mouseenter_handler_1*/ ctx[33]);
	plaininput.$on("mouseleave", /*mouseleave_handler_1*/ ctx[34]);

	return {
		c() {
			create_component(plaininput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(plaininput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const plaininput_changes = {};
			if (dirty[0] & /*i18n*/ 16384) plaininput_changes.i18n = /*i18n*/ ctx[14];
			if (dirty[0] & /*indented*/ 512) plaininput_changes.indented = /*indented*/ ctx[9];
			if (dirty[0] & /*credentials*/ 2048) plaininput_changes.credentials = /*credentials*/ ctx[11];
			if (dirty[0] & /*id*/ 4096) plaininput_changes.id = /*id*/ ctx[12];

			if (!updating_node && dirty[0] & /*node*/ 4) {
				updating_node = true;
				plaininput_changes.node = /*node*/ ctx[2];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty[0] & /*prop*/ 8) {
				updating_prop = true;
				plaininput_changes.prop = /*prop*/ ctx[3];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_icon && dirty[0] & /*icon*/ 16) {
				updating_icon = true;
				plaininput_changes.icon = /*icon*/ ctx[4];
				add_flush_callback(() => updating_icon = false);
			}

			if (!updating_label && dirty[0] & /*label*/ 32) {
				updating_label = true;
				plaininput_changes.label = /*label*/ ctx[5];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty[0] & /*disabled*/ 1024) {
				updating_disabled = true;
				plaininput_changes.disabled = /*disabled*/ ctx[10];
				add_flush_callback(() => updating_disabled = false);
			}

			if (!updating_value && dirty[0] & /*value*/ 1) {
				updating_value = true;
				plaininput_changes.value = /*value*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_type && dirty[0] & /*type*/ 2) {
				updating_type = true;
				plaininput_changes.type = /*type*/ ctx[1];
				add_flush_callback(() => updating_type = false);
			}

			if (!updating_placeholder && dirty[0] & /*placeholder*/ 64) {
				updating_placeholder = true;
				plaininput_changes.placeholder = /*placeholder*/ ctx[6];
				add_flush_callback(() => updating_placeholder = false);
			}

			if (!updating_maximize && dirty[0] & /*maximize*/ 256) {
				updating_maximize = true;
				plaininput_changes.maximize = /*maximize*/ ctx[8];
				add_flush_callback(() => updating_maximize = false);
			}

			plaininput.$set(plaininput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(plaininput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(plaininput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(plaininput, detaching);
		}
	};
}

// (40:2) {#if type === 'config'}
function create_if_block$5(ctx) {
	let confignodeinput;
	let updating_node;
	let updating_prop;
	let updating_label;
	let updating_disabled;
	let current;

	function confignodeinput_node_binding(value) {
		/*confignodeinput_node_binding*/ ctx[16](value);
	}

	function confignodeinput_prop_binding(value) {
		/*confignodeinput_prop_binding*/ ctx[17](value);
	}

	function confignodeinput_label_binding(value) {
		/*confignodeinput_label_binding*/ ctx[18](value);
	}

	function confignodeinput_disabled_binding(value) {
		/*confignodeinput_disabled_binding*/ ctx[19](value);
	}

	let confignodeinput_props = {
		icon: /*icon*/ ctx[4],
		i18n: /*i18n*/ ctx[14],
		indented: /*indented*/ ctx[9]
	};

	if (/*node*/ ctx[2] !== void 0) {
		confignodeinput_props.node = /*node*/ ctx[2];
	}

	if (/*prop*/ ctx[3] !== void 0) {
		confignodeinput_props.prop = /*prop*/ ctx[3];
	}

	if (/*label*/ ctx[5] !== void 0) {
		confignodeinput_props.label = /*label*/ ctx[5];
	}

	if (/*disabled*/ ctx[10] !== void 0) {
		confignodeinput_props.disabled = /*disabled*/ ctx[10];
	}

	confignodeinput = new ConfigNodeInput({ props: confignodeinput_props });
	binding_callbacks.push(() => bind(confignodeinput, 'node', confignodeinput_node_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'prop', confignodeinput_prop_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'label', confignodeinput_label_binding));
	binding_callbacks.push(() => bind(confignodeinput, 'disabled', confignodeinput_disabled_binding));
	confignodeinput.$on("change", /*change_handler*/ ctx[20]);
	confignodeinput.$on("mouseenter", /*mouseenter_handler*/ ctx[21]);
	confignodeinput.$on("mouseleave", /*mouseleave_handler*/ ctx[22]);

	return {
		c() {
			create_component(confignodeinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(confignodeinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const confignodeinput_changes = {};
			if (dirty[0] & /*icon*/ 16) confignodeinput_changes.icon = /*icon*/ ctx[4];
			if (dirty[0] & /*i18n*/ 16384) confignodeinput_changes.i18n = /*i18n*/ ctx[14];
			if (dirty[0] & /*indented*/ 512) confignodeinput_changes.indented = /*indented*/ ctx[9];

			if (!updating_node && dirty[0] & /*node*/ 4) {
				updating_node = true;
				confignodeinput_changes.node = /*node*/ ctx[2];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty[0] & /*prop*/ 8) {
				updating_prop = true;
				confignodeinput_changes.prop = /*prop*/ ctx[3];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_label && dirty[0] & /*label*/ 32) {
				updating_label = true;
				confignodeinput_changes.label = /*label*/ ctx[5];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty[0] & /*disabled*/ 1024) {
				updating_disabled = true;
				confignodeinput_changes.disabled = /*disabled*/ ctx[10];
				add_flush_callback(() => updating_disabled = false);
			}

			confignodeinput.$set(confignodeinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(confignodeinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(confignodeinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(confignodeinput, detaching);
		}
	};
}

// (39:0) <Row clazz="sir-input" {inline} {maximize} {fading}>
function create_default_slot$5(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$5, create_else_block$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*type*/ ctx[1] === 'config') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function create_fragment$6(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				clazz: "sir-input",
				inline: /*inline*/ ctx[7],
				maximize: /*maximize*/ ctx[8],
				fading: /*fading*/ ctx[13],
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const row_changes = {};
			if (dirty[0] & /*inline*/ 128) row_changes.inline = /*inline*/ ctx[7];
			if (dirty[0] & /*maximize*/ 256) row_changes.maximize = /*maximize*/ ctx[8];
			if (dirty[0] & /*fading*/ 8192) row_changes.fading = /*fading*/ ctx[13];

			if (dirty[0] & /*icon, i18n, indented, node, prop, label, disabled, type, credentials, id, value, placeholder, maximize*/ 24447 | dirty[1] & /*$$scope*/ 16) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { node, prop, value, type, icon, credentials, label, placeholder, id, inline = false, maximize = true, indented = false, checked, disabled = false, fading = true, i18n } = $$props;
	inline = getBooleanFrom(inline);
	maximize = getBooleanFrom(maximize);
	disabled = getBooleanFrom(disabled);
	indented = getBooleanFrom(indented);

	// loading node: if only node is bound for any input field in the svelte code, value would be undefined if the input field is empty or false
	if (type !== 'checkbox' && typeof value === 'undefined' && typeof node?.[prop] !== 'undefined') {
		value = node[prop];
	} else if (type === 'checkbox' && typeof value === 'undefined') {
		// special case for checkbox: bind:checked (offical property) could also be used and has prio before getting it possibly from node[prop]
		if (typeof checked !== 'undefined') {
			value = getBooleanFrom(checked);
		} else if (typeof node?.[prop] !== 'undefined') {
			value = getBooleanFrom(node[prop]);
		}
	}

	function confignodeinput_node_binding(value) {
		node = value;
		$$invalidate(2, node);
	}

	function confignodeinput_prop_binding(value) {
		prop = value;
		$$invalidate(3, prop);
	}

	function confignodeinput_label_binding(value) {
		label = value;
		$$invalidate(5, label);
	}

	function confignodeinput_disabled_binding(value) {
		disabled = value;
		$$invalidate(10, disabled);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function plaininput_node_binding(value) {
		node = value;
		$$invalidate(2, node);
	}

	function plaininput_prop_binding(value) {
		prop = value;
		$$invalidate(3, prop);
	}

	function plaininput_icon_binding(value) {
		icon = value;
		$$invalidate(4, icon);
	}

	function plaininput_label_binding(value) {
		label = value;
		$$invalidate(5, label);
	}

	function plaininput_disabled_binding(value) {
		disabled = value;
		$$invalidate(10, disabled);
	}

	function plaininput_value_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	function plaininput_type_binding(value) {
		type = value;
		$$invalidate(1, type);
	}

	function plaininput_placeholder_binding(value) {
		placeholder = value;
		$$invalidate(6, placeholder);
	}

	function plaininput_maximize_binding(value) {
		maximize = value;
		$$invalidate(8, maximize);
	}

	function change_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(2, node = $$props.node);
		if ('prop' in $$props) $$invalidate(3, prop = $$props.prop);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('type' in $$props) $$invalidate(1, type = $$props.type);
		if ('icon' in $$props) $$invalidate(4, icon = $$props.icon);
		if ('credentials' in $$props) $$invalidate(11, credentials = $$props.credentials);
		if ('label' in $$props) $$invalidate(5, label = $$props.label);
		if ('placeholder' in $$props) $$invalidate(6, placeholder = $$props.placeholder);
		if ('id' in $$props) $$invalidate(12, id = $$props.id);
		if ('inline' in $$props) $$invalidate(7, inline = $$props.inline);
		if ('maximize' in $$props) $$invalidate(8, maximize = $$props.maximize);
		if ('indented' in $$props) $$invalidate(9, indented = $$props.indented);
		if ('checked' in $$props) $$invalidate(15, checked = $$props.checked);
		if ('disabled' in $$props) $$invalidate(10, disabled = $$props.disabled);
		if ('fading' in $$props) $$invalidate(13, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(14, i18n = $$props.i18n);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*type, checked, value*/ 32771) {
			// if checkbox has checked bound it must be updated with the value property (needed)
			if (type === 'checkbox' && typeof checked !== 'undefined' && typeof value !== 'undefined') {
				$$invalidate(15, checked = getBooleanFrom(value));
			}
		}
	};

	return [
		value,
		type,
		node,
		prop,
		icon,
		label,
		placeholder,
		inline,
		maximize,
		indented,
		disabled,
		credentials,
		id,
		fading,
		i18n,
		checked,
		confignodeinput_node_binding,
		confignodeinput_prop_binding,
		confignodeinput_label_binding,
		confignodeinput_disabled_binding,
		change_handler,
		mouseenter_handler,
		mouseleave_handler,
		plaininput_node_binding,
		plaininput_prop_binding,
		plaininput_icon_binding,
		plaininput_label_binding,
		plaininput_disabled_binding,
		plaininput_value_binding,
		plaininput_type_binding,
		plaininput_placeholder_binding,
		plaininput_maximize_binding,
		change_handler_1,
		mouseenter_handler_1,
		mouseleave_handler_1
	];
}

class Input extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$6,
			create_fragment$6,
			safe_not_equal,
			{
				node: 2,
				prop: 3,
				value: 0,
				type: 1,
				icon: 4,
				credentials: 11,
				label: 5,
				placeholder: 6,
				id: 12,
				inline: 7,
				maximize: 8,
				indented: 9,
				checked: 15,
				disabled: 10,
				fading: 13,
				i18n: 14
			},
			add_css$5,
			[-1, -1]
		);
	}
}

/* ../svelte-integration-red/components/PlainTypedInput.svelte generated by Svelte v3.42.4 */

function add_css$4(target) {
	append_styles(target, "svelte-cmqtbf", ".maximize.svelte-cmqtbf{width:100%}.sir-form-row :is(.red-ui-typedInput-container, .red-ui-typedInput-input-wrap){display:inline-flex;align-items:center}.sir-form-row button:is(.red-ui-typedInput-type-select, .red-ui-typedInput-option-expand, .red-ui-typedInput-option-trigger){display:inline-flex;align-items:center;line-height:32px}");
}

// (102:0) {:else}
function create_else_block$2(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: Neither property nor type property name given.";
			attr(span, "class", "maximize svelte-cmqtbf");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (100:19) 
function create_if_block_5$2(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: No property name given.";
			attr(span, "class", "maximize svelte-cmqtbf");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (98:15) 
function create_if_block_4$3(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "Error: No type property name given.";
			attr(span, "class", "maximize svelte-cmqtbf");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (88:0) {#if !updateNode || (prop && typeProp)}
function create_if_block$4(ctx) {
	let t0;
	let input0;
	let input0_id_value;
	let t1;
	let input1;
	let input1_id_value;
	let mounted;
	let dispose;

	function select_block_type_1(ctx, dirty) {
		if (/*label*/ ctx[3]) return create_if_block_1$4;
		if (/*indented*/ ctx[7]) return create_if_block_3$3;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			t0 = space();
			input0 = element("input");
			t1 = space();
			input1 = element("input");
			attr(input0, "type", "text");
			attr(input0, "id", input0_id_value = "node-input-" + /*id*/ ctx[4]);
			attr(input0, "style", /*style*/ ctx[8]);
			attr(input1, "type", "hidden");
			attr(input1, "id", input1_id_value = "node-input-" + /*id*/ ctx[4] + "-type");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, input0, anchor);
			set_input_value(input0, /*value*/ ctx[0]);
			insert(target, t1, anchor);
			insert(target, input1, anchor);
			set_input_value(input1, /*type*/ ctx[1]);

			if (!mounted) {
				dispose = [
					listen(input0, "mouseenter", /*mouseenter_handler_1*/ ctx[18]),
					listen(input0, "mouseleav", /*mouseleav_handler*/ ctx[19]),
					listen(input0, "input", /*input0_input_handler*/ ctx[23]),
					listen(input1, "mouseenter", /*mouseenter_handler_2*/ ctx[16]),
					listen(input1, "mouseleave", /*mouseleave_handler_1*/ ctx[17]),
					listen(input1, "input", /*input1_input_handler*/ ctx[24])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(t0.parentNode, t0);
				}
			}

			if (dirty & /*id*/ 16 && input0_id_value !== (input0_id_value = "node-input-" + /*id*/ ctx[4])) {
				attr(input0, "id", input0_id_value);
			}

			if (dirty & /*style*/ 256) {
				attr(input0, "style", /*style*/ ctx[8]);
			}

			if (dirty & /*value*/ 1 && input0.value !== /*value*/ ctx[0]) {
				set_input_value(input0, /*value*/ ctx[0]);
			}

			if (dirty & /*id*/ 16 && input1_id_value !== (input1_id_value = "node-input-" + /*id*/ ctx[4] + "-type")) {
				attr(input1, "id", input1_id_value);
			}

			if (dirty & /*type*/ 2) {
				set_input_value(input1, /*type*/ ctx[1]);
			}
		},
		d(detaching) {
			if (if_block) {
				if_block.d(detaching);
			}

			if (detaching) detach(t0);
			if (detaching) detach(input0);
			if (detaching) detach(t1);
			if (detaching) detach(input1);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (91:21) 
function create_if_block_3$3(ctx) {
	let label_1;

	return {
		c() {
			label_1 = element("label");
			set_style(label_1, "pointer", "cursor: initial");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(label_1);
		}
	};
}

// (89:2) {#if label}
function create_if_block_1$4(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let mounted;
	let dispose;
	let if_block = /*icon*/ ctx[2] && create_if_block_2$3(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[3]);
			attr(label_1, "for", label_1_for_value = "node-input-" + /*id*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);

			if (!mounted) {
				dispose = [
					listen(label_1, "mouseenter", /*mouseenter_handler*/ ctx[20]),
					listen(label_1, "mouseleave", /*mouseleave_handler*/ ctx[21]),
					listen(label_1, "click", /*click_handler*/ ctx[22])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$3(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*label*/ 8) set_data(t1, /*label*/ ctx[3]);

			if (dirty & /*id*/ 16 && label_1_for_value !== (label_1_for_value = "node-input-" + /*id*/ ctx[4])) {
				attr(label_1, "for", label_1_for_value);
			}
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (90:91) {#if icon}
function create_if_block_2$3(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[2] + " svelte-cmqtbf");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 4 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[2] + " svelte-cmqtbf")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

function create_fragment$5(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (!/*updateNode*/ ctx[9] || /*prop*/ ctx[5] && /*typeProp*/ ctx[6]) return create_if_block$4;
		if (/*prop*/ ctx[5]) return create_if_block_4$3;
		if (/*typeProp*/ ctx[6]) return create_if_block_5$2;
		return create_else_block$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let { node, prop, typeProp, value, type, types, icon, label, id, indented = false, maximize, disabled = false, i18n } = $$props;

	if (!id) {
		id = getId(prop);
	}

	let defaults = {};

	if (node) {
		defaults = node._def.defaults;
	}

	const dispatch = createEventDispatcher();
	const updateNode = typeof node !== 'undefined';

	if (label !== false) {
		label = label || defaults[prop] && defaults[prop].label || prop;
	}

	if (!types && node[typeProp]) {
		types = defaults[typeProp].types;
	}

	icon = icon || defaults?.[prop]?.icon || '';
	if (label) label = i18nTranslate(RED, node, i18n, label);
	let initialized = false;

	onMount(() => {
		window.$('#node-input-' + id).typedInput({
			types,
			typeField: `#node-input-${id}-type`
		});

		window.$('#node-input-' + id).typedInput('disable', disabled); // no effect if stated in the object above

		window.$('#node-input-' + id).on('change', (type, value) => {
			value = window.$('#node-input-' + id).typedInput('value');
			type = window.$('#node-input-' + id).typedInput('type');

			if (updateNode) {
				$$invalidate(11, node[prop] = value, node);
				$$invalidate(11, node[typeProp] = type, node);
			}

			dispatch('change', { id, value, type });
		});

		initialized = true;
	});

	// we set style for typed input direct as classes won't work
	let style = 'margin-right: 0px; ';

	if (maximize) style += 'width: 100%;';

	const setFocus = e => {
		// TypedInput has a dummy input field which has no id. Therefor we must reroute the label onclick -> focus.
		window.$(e.target.parentNode.children).find('.red-ui-typedInput-input').focus();
	};

	const update = (key, value) => {
		if (initialized) {
			window.$('#node-input-' + id).typedInput(key, value);
		}
	};

	function mouseenter_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleav_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler = e => setFocus(e);

	function input0_input_handler() {
		value = this.value;
		(($$invalidate(0, value), $$invalidate(11, node)), $$invalidate(5, prop));
	}

	function input1_input_handler() {
		type = this.value;
		(($$invalidate(1, type), $$invalidate(11, node)), $$invalidate(6, typeProp));
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(11, node = $$props.node);
		if ('prop' in $$props) $$invalidate(5, prop = $$props.prop);
		if ('typeProp' in $$props) $$invalidate(6, typeProp = $$props.typeProp);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('type' in $$props) $$invalidate(1, type = $$props.type);
		if ('types' in $$props) $$invalidate(12, types = $$props.types);
		if ('icon' in $$props) $$invalidate(2, icon = $$props.icon);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('id' in $$props) $$invalidate(4, id = $$props.id);
		if ('indented' in $$props) $$invalidate(7, indented = $$props.indented);
		if ('maximize' in $$props) $$invalidate(13, maximize = $$props.maximize);
		if ('disabled' in $$props) $$invalidate(14, disabled = $$props.disabled);
		if ('i18n' in $$props) $$invalidate(15, i18n = $$props.i18n);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*node, prop, value*/ 2081) {
			$$invalidate(0, value = updateNode && node[prop] || value);
		}

		if ($$self.$$.dirty & /*node, typeProp, type*/ 2114) {
			$$invalidate(1, type = updateNode && node[typeProp] || type);
		}

		if ($$self.$$.dirty & /*types*/ 4096) {
			update('types', types);
		}

		if ($$self.$$.dirty & /*value*/ 1) {
			if (updateNode) update('value', value);
		}

		if ($$self.$$.dirty & /*type*/ 2) {
			if (updateNode) update('type', type);
		}

		if ($$self.$$.dirty & /*disabled*/ 16384) {
			update('disable', disabled);
		}
	};

	return [
		value,
		type,
		icon,
		label,
		id,
		prop,
		typeProp,
		indented,
		style,
		updateNode,
		setFocus,
		node,
		types,
		maximize,
		disabled,
		i18n,
		mouseenter_handler_2,
		mouseleave_handler_1,
		mouseenter_handler_1,
		mouseleav_handler,
		mouseenter_handler,
		mouseleave_handler,
		click_handler,
		input0_input_handler,
		input1_input_handler
	];
}

class PlainTypedInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$5,
			create_fragment$5,
			safe_not_equal,
			{
				node: 11,
				prop: 5,
				typeProp: 6,
				value: 0,
				type: 1,
				types: 12,
				icon: 2,
				label: 3,
				id: 4,
				indented: 7,
				maximize: 13,
				disabled: 14,
				i18n: 15
			},
			add_css$4
		);
	}
}

/* ../svelte-integration-red/components/TypedInput.svelte generated by Svelte v3.42.4 */

function create_default_slot$4(ctx) {
	let plaintypedinput;
	let updating_node;
	let updating_prop;
	let updating_typeProp;
	let updating_value;
	let updating_type;
	let updating_types;
	let updating_label;
	let updating_disabled;
	let current;

	function plaintypedinput_node_binding(value) {
		/*plaintypedinput_node_binding*/ ctx[15](value);
	}

	function plaintypedinput_prop_binding(value) {
		/*plaintypedinput_prop_binding*/ ctx[16](value);
	}

	function plaintypedinput_typeProp_binding(value) {
		/*plaintypedinput_typeProp_binding*/ ctx[17](value);
	}

	function plaintypedinput_value_binding(value) {
		/*plaintypedinput_value_binding*/ ctx[18](value);
	}

	function plaintypedinput_type_binding(value) {
		/*plaintypedinput_type_binding*/ ctx[19](value);
	}

	function plaintypedinput_types_binding(value) {
		/*plaintypedinput_types_binding*/ ctx[20](value);
	}

	function plaintypedinput_label_binding(value) {
		/*plaintypedinput_label_binding*/ ctx[21](value);
	}

	function plaintypedinput_disabled_binding(value) {
		/*plaintypedinput_disabled_binding*/ ctx[22](value);
	}

	let plaintypedinput_props = {
		icon: /*icon*/ ctx[11],
		maximize: /*maximize*/ ctx[8],
		id: /*id*/ ctx[12],
		i18n: /*i18n*/ ctx[14],
		indented: /*indented*/ ctx[10]
	};

	if (/*node*/ ctx[0] !== void 0) {
		plaintypedinput_props.node = /*node*/ ctx[0];
	}

	if (/*prop*/ ctx[1] !== void 0) {
		plaintypedinput_props.prop = /*prop*/ ctx[1];
	}

	if (/*typeProp*/ ctx[2] !== void 0) {
		plaintypedinput_props.typeProp = /*typeProp*/ ctx[2];
	}

	if (/*value*/ ctx[3] !== void 0) {
		plaintypedinput_props.value = /*value*/ ctx[3];
	}

	if (/*type*/ ctx[4] !== void 0) {
		plaintypedinput_props.type = /*type*/ ctx[4];
	}

	if (/*types*/ ctx[5] !== void 0) {
		plaintypedinput_props.types = /*types*/ ctx[5];
	}

	if (/*label*/ ctx[6] !== void 0) {
		plaintypedinput_props.label = /*label*/ ctx[6];
	}

	if (/*disabled*/ ctx[9] !== void 0) {
		plaintypedinput_props.disabled = /*disabled*/ ctx[9];
	}

	plaintypedinput = new PlainTypedInput({ props: plaintypedinput_props });
	binding_callbacks.push(() => bind(plaintypedinput, 'node', plaintypedinput_node_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'prop', plaintypedinput_prop_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'typeProp', plaintypedinput_typeProp_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'value', plaintypedinput_value_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'type', plaintypedinput_type_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'types', plaintypedinput_types_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'label', plaintypedinput_label_binding));
	binding_callbacks.push(() => bind(plaintypedinput, 'disabled', plaintypedinput_disabled_binding));
	plaintypedinput.$on("change", /*change_handler*/ ctx[23]);
	plaintypedinput.$on("mouseenter", /*mouseenter_handler*/ ctx[24]);
	plaintypedinput.$on("mouseleave", /*mouseleave_handler*/ ctx[25]);

	return {
		c() {
			create_component(plaintypedinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(plaintypedinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const plaintypedinput_changes = {};
			if (dirty & /*icon*/ 2048) plaintypedinput_changes.icon = /*icon*/ ctx[11];
			if (dirty & /*maximize*/ 256) plaintypedinput_changes.maximize = /*maximize*/ ctx[8];
			if (dirty & /*id*/ 4096) plaintypedinput_changes.id = /*id*/ ctx[12];
			if (dirty & /*i18n*/ 16384) plaintypedinput_changes.i18n = /*i18n*/ ctx[14];
			if (dirty & /*indented*/ 1024) plaintypedinput_changes.indented = /*indented*/ ctx[10];

			if (!updating_node && dirty & /*node*/ 1) {
				updating_node = true;
				plaintypedinput_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			if (!updating_prop && dirty & /*prop*/ 2) {
				updating_prop = true;
				plaintypedinput_changes.prop = /*prop*/ ctx[1];
				add_flush_callback(() => updating_prop = false);
			}

			if (!updating_typeProp && dirty & /*typeProp*/ 4) {
				updating_typeProp = true;
				plaintypedinput_changes.typeProp = /*typeProp*/ ctx[2];
				add_flush_callback(() => updating_typeProp = false);
			}

			if (!updating_value && dirty & /*value*/ 8) {
				updating_value = true;
				plaintypedinput_changes.value = /*value*/ ctx[3];
				add_flush_callback(() => updating_value = false);
			}

			if (!updating_type && dirty & /*type*/ 16) {
				updating_type = true;
				plaintypedinput_changes.type = /*type*/ ctx[4];
				add_flush_callback(() => updating_type = false);
			}

			if (!updating_types && dirty & /*types*/ 32) {
				updating_types = true;
				plaintypedinput_changes.types = /*types*/ ctx[5];
				add_flush_callback(() => updating_types = false);
			}

			if (!updating_label && dirty & /*label*/ 64) {
				updating_label = true;
				plaintypedinput_changes.label = /*label*/ ctx[6];
				add_flush_callback(() => updating_label = false);
			}

			if (!updating_disabled && dirty & /*disabled*/ 512) {
				updating_disabled = true;
				plaintypedinput_changes.disabled = /*disabled*/ ctx[9];
				add_flush_callback(() => updating_disabled = false);
			}

			plaintypedinput.$set(plaintypedinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(plaintypedinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(plaintypedinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(plaintypedinput, detaching);
		}
	};
}

function create_fragment$4(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				clazz: "sir-input",
				inline: /*inline*/ ctx[7],
				fading: /*fading*/ ctx[13],
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*inline*/ 128) row_changes.inline = /*inline*/ ctx[7];
			if (dirty & /*fading*/ 8192) row_changes.fading = /*fading*/ ctx[13];

			if (dirty & /*$$scope, icon, maximize, id, i18n, indented, node, prop, typeProp, value, type, types, label, disabled*/ 67133311) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { node, prop, typeProp, value, type, types, icon, label, id, inline = false, maximize = true, disabled = false, indented = false, fading = true, i18n } = $$props;
	inline = getBooleanFrom(inline);
	disabled = getBooleanFrom(disabled);
	indented = getBooleanFrom(indented);
	maximize = getBooleanFrom(maximize);

	function plaintypedinput_node_binding(value) {
		node = value;
		$$invalidate(0, node);
	}

	function plaintypedinput_prop_binding(value) {
		prop = value;
		$$invalidate(1, prop);
	}

	function plaintypedinput_typeProp_binding(value) {
		typeProp = value;
		$$invalidate(2, typeProp);
	}

	function plaintypedinput_value_binding(value$1) {
		value = value$1;
		$$invalidate(3, value);
	}

	function plaintypedinput_type_binding(value) {
		type = value;
		$$invalidate(4, type);
	}

	function plaintypedinput_types_binding(value) {
		types = value;
		$$invalidate(5, types);
	}

	function plaintypedinput_label_binding(value) {
		label = value;
		$$invalidate(6, label);
	}

	function plaintypedinput_disabled_binding(value) {
		disabled = value;
		$$invalidate(9, disabled);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
		if ('prop' in $$props) $$invalidate(1, prop = $$props.prop);
		if ('typeProp' in $$props) $$invalidate(2, typeProp = $$props.typeProp);
		if ('value' in $$props) $$invalidate(3, value = $$props.value);
		if ('type' in $$props) $$invalidate(4, type = $$props.type);
		if ('types' in $$props) $$invalidate(5, types = $$props.types);
		if ('icon' in $$props) $$invalidate(11, icon = $$props.icon);
		if ('label' in $$props) $$invalidate(6, label = $$props.label);
		if ('id' in $$props) $$invalidate(12, id = $$props.id);
		if ('inline' in $$props) $$invalidate(7, inline = $$props.inline);
		if ('maximize' in $$props) $$invalidate(8, maximize = $$props.maximize);
		if ('disabled' in $$props) $$invalidate(9, disabled = $$props.disabled);
		if ('indented' in $$props) $$invalidate(10, indented = $$props.indented);
		if ('fading' in $$props) $$invalidate(13, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(14, i18n = $$props.i18n);
	};

	return [
		node,
		prop,
		typeProp,
		value,
		type,
		types,
		label,
		inline,
		maximize,
		disabled,
		indented,
		icon,
		id,
		fading,
		i18n,
		plaintypedinput_node_binding,
		plaintypedinput_prop_binding,
		plaintypedinput_typeProp_binding,
		plaintypedinput_value_binding,
		plaintypedinput_type_binding,
		plaintypedinput_types_binding,
		plaintypedinput_label_binding,
		plaintypedinput_disabled_binding,
		change_handler,
		mouseenter_handler,
		mouseleave_handler
	];
}

class TypedInput extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			node: 0,
			prop: 1,
			typeProp: 2,
			value: 3,
			type: 4,
			types: 5,
			icon: 11,
			label: 6,
			id: 12,
			inline: 7,
			maximize: 8,
			disabled: 9,
			indented: 10,
			fading: 13,
			i18n: 14
		});
	}
}

/* ../svelte-integration-red/components/EditableList.svelte generated by Svelte v3.42.4 */

function add_css$3(target) {
	append_styles(target, "svelte-xatqjb", "li.svelte-xatqjb.svelte-xatqjb{display:inline-flex;width:100%;align-items:center}li.svelte-xatqjb .red-ui-editableList-item-content.svelte-xatqjb{width:100%;margin:0px 8px}li.svelte-xatqjb .red-ui-editableList-item-remove.svelte-xatqjb{position:inherit;margin:0px 8px 0px 0px}li.svelte-xatqjb .red-ui-editableList-item-handle.svelte-xatqjb{position:inherit;margin:0px 3px 0px 8px}.disabled.svelte-xatqjb.svelte-xatqjb{pointer-events:none}.sir-form-row.sir-editable-list{align-items:flex-start;flex-direction:column}.sir-editable-list label{width:auto;margin-bottom:5px}.sir-form-row.sir-editable-list div:last-child{margin-bottom:0px}.sir-form-row.sir-editable-list .red-ui-editableList-container{min-height:100px;overflow-y:auto !important}.sir-form-row.sir-editable-list .red-ui-editableList{width:100%}.sir-form-row.sir-editable-list .red-ui-editableList-item-remove button{min-width:auto}");
}

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	child_ctx[25] = i;
	return child_ctx;
}

const get_default_slot_changes = dirty => ({
	element: dirty & /*elements*/ 1,
	index: dirty & /*elements*/ 1
});

const get_default_slot_context = ctx => ({
	element: /*element*/ ctx[23],
	index: /*index*/ ctx[25]
});

// (97:2) {#if label}
function create_if_block_3$2(ctx) {
	let label_1;
	let t0;
	let t1;
	let if_block = /*icon*/ ctx[10] && create_if_block_4$2(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[4]);
			attr(label_1, "for", /*nodeInputId*/ ctx[12]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[10]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4$2(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*label*/ 16) set_data(t1, /*label*/ ctx[4]);
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
		}
	};
}

// (98:32) {#if icon}
function create_if_block_4$2(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[10] + " svelte-xatqjb");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 1024 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[10] + " svelte-xatqjb")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (103:8) {#if sortable}
function create_if_block_2$2(ctx) {
	let i;

	return {
		c() {
			i = element("i");
			attr(i, "class", "red-ui-editableList-item-handle fa fa-bars svelte-xatqjb");
			toggle_class(i, "disabled", /*disabled*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*disabled*/ 32) {
				toggle_class(i, "disabled", /*disabled*/ ctx[5]);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (109:8) {#if removable}
function create_if_block_1$3(ctx) {
	let div;
	let button;
	let current;

	function click_handler() {
		return /*click_handler*/ ctx[20](/*index*/ ctx[25]);
	}

	button = new Button({
			props: {
				small: true,
				class: "red-ui-editableList-item-remove",
				icon: "remove",
				disabled: /*disabled*/ ctx[5]
			}
		});

	button.$on("click", click_handler);

	return {
		c() {
			div = element("div");
			create_component(button.$$.fragment);
			attr(div, "class", "red-ui-editableList-item-remove svelte-xatqjb");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const button_changes = {};
			if (dirty & /*disabled*/ 32) button_changes.disabled = /*disabled*/ ctx[5];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(button);
		}
	};
}

// (101:4) {#each elements as element, index (element.id || index)}
function create_each_block$2(key_1, ctx) {
	let li;
	let t0;
	let div;
	let t1;
	let t2;
	let li_id_value;
	let current;
	let if_block0 = /*sortable*/ ctx[2] && create_if_block_2$2(ctx);
	const default_slot_template = /*#slots*/ ctx[19].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], get_default_slot_context);
	let if_block1 = /*removable*/ ctx[3] && create_if_block_1$3(ctx);

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			attr(div, "class", "red-ui-editableList-item-content svelte-xatqjb");
			attr(li, "id", li_id_value = /*index*/ ctx[25]);
			attr(li, "class", "svelte-xatqjb");
			toggle_class(li, "red-ui-editableList-item-sortable", /*sortable*/ ctx[2]);
			toggle_class(li, "red-ui-editableList-item-removable", /*removable*/ ctx[3]);
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			if (if_block0) if_block0.m(li, null);
			append(li, t0);
			append(li, div);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append(li, t1);
			if (if_block1) if_block1.m(li, null);
			append(li, t2);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*sortable*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$2(ctx);
					if_block0.c();
					if_block0.m(li, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, elements*/ 2097153)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[21],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, get_default_slot_changes),
						get_default_slot_context
					);
				}
			}

			if (/*removable*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*removable*/ 8) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(li, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*elements*/ 1 && li_id_value !== (li_id_value = /*index*/ ctx[25])) {
				attr(li, "id", li_id_value);
			}

			if (dirty & /*sortable*/ 4) {
				toggle_class(li, "red-ui-editableList-item-sortable", /*sortable*/ ctx[2]);
			}

			if (dirty & /*removable*/ 8) {
				toggle_class(li, "red-ui-editableList-item-removable", /*removable*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(li);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};
}

// (117:2) {#if addButton}
function create_if_block$3(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				style: "margin-top: 6px;",
				icon: "plus",
				disabled: /*disabled*/ ctx[5],
				label: " " + RED._("editableList.add"),
				small: true
			}
		});

	button.$on("click", /*addHandler*/ ctx[13]);

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*disabled*/ 32) button_changes.disabled = /*disabled*/ ctx[5];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (96:0) <Row clazz="sir-editable-list" {inline} {indented} {maximize} {fading}>
function create_default_slot$3(ctx) {
	let t0;
	let ol;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t1;
	let if_block1_anchor;
	let current;
	let if_block0 = /*label*/ ctx[4] && create_if_block_3$2(ctx);
	let each_value = /*elements*/ ctx[0];
	const get_key = ctx => /*element*/ ctx[23].id || /*index*/ ctx[25];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$2(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
	}

	let if_block1 = /*addButton*/ ctx[1] && create_if_block$3(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			ol = element("ol");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(ol, "id", /*nodeInputId*/ ctx[12]);
			attr(ol, "style", /*style*/ ctx[9]);
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, ol, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ol, null);
			}

			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$2(ctx);
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*elements, sortable, removable, disabled, removeHandler, $$scope*/ 2113581) {
				each_value = /*elements*/ ctx[0];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ol, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
				check_outros();
			}

			if (!current || dirty & /*style*/ 512) {
				attr(ol, "style", /*style*/ ctx[9]);
			}

			if (/*addButton*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*addButton*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block1);
			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach(t0);
			if (detaching) detach(ol);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach(if_block1_anchor);
		}
	};
}

function create_fragment$3(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				clazz: "sir-editable-list",
				inline: /*inline*/ ctx[7],
				indented: /*indented*/ ctx[8],
				maximize: /*maximize*/ ctx[6],
				fading: /*fading*/ ctx[11],
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*inline*/ 128) row_changes.inline = /*inline*/ ctx[7];
			if (dirty & /*indented*/ 256) row_changes.indented = /*indented*/ ctx[8];
			if (dirty & /*maximize*/ 64) row_changes.maximize = /*maximize*/ ctx[6];
			if (dirty & /*fading*/ 2048) row_changes.fading = /*fading*/ ctx[11];

			if (dirty & /*$$scope, disabled, addButton, style, elements, sortable, removable, label, icon*/ 2098751) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { id = getId() } = $$props;
	let { node, elements, addButton = false, sortable = false, removable = false, height = 300, style, icon, label = '', disabled = false, maximize = false, inline = false, indented = false, fading = true, i18n } = $$props;
	addButton = getBooleanFrom(addButton);
	sortable = getBooleanFrom(sortable);
	removable = getBooleanFrom(removable);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	inline = getBooleanFrom(inline);
	indented = getBooleanFrom(indented);
	if (label) label = i18nTranslate(RED, node, i18n, label);
	const nodeInputId = 'node-input-' + id + '-container';
	const dispatch = createEventDispatcher();

	onMount(() => {
		let setToHeight = height;
		if (!setToHeight || isNaN(setToHeight) && setToHeight.startsWith('100%')) setToHeight = 'auto';

		window.$('#' + nodeInputId).editableList({
			addButton: false,
			sortable,
			height: setToHeight,
			sortItems: items => {
				const before = [...elements];
				const orderedElements = [];
				const childrenInOriginalOrder = [];

				for (let i = 0; i < items.length; i++) {
					orderedElements[i] = elements[items[i].prevObject[0].id];
					childrenInOriginalOrder[items[i].prevObject[0].id] = items[i].prevObject[0];
				}

				// Hack: Reorder elements
				// This allows us to use the built-in sortable behaviour of Node-RED / jQuery
				// while preserving a correct rendering through Svelte
				const container = window.$('#' + nodeInputId);

				container.append(childrenInOriginalOrder);
				$$invalidate(0, elements = orderedElements);
				dispatch('sort', { before, after: orderedElements });
			}
		});
	});

	function addHandler() {
		dispatch('add', { index: elements.length });
	}

	function removeHandler(index) {
		const removed = elements[index];
		$$invalidate(0, elements = [...elements.slice(0, index), ...elements.slice(index + 1)]);
		dispatch('remove', { removed });
	}

	const click_handler = index => removeHandler(index);

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(15, id = $$props.id);
		if ('node' in $$props) $$invalidate(16, node = $$props.node);
		if ('elements' in $$props) $$invalidate(0, elements = $$props.elements);
		if ('addButton' in $$props) $$invalidate(1, addButton = $$props.addButton);
		if ('sortable' in $$props) $$invalidate(2, sortable = $$props.sortable);
		if ('removable' in $$props) $$invalidate(3, removable = $$props.removable);
		if ('height' in $$props) $$invalidate(17, height = $$props.height);
		if ('style' in $$props) $$invalidate(9, style = $$props.style);
		if ('icon' in $$props) $$invalidate(10, icon = $$props.icon);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ('maximize' in $$props) $$invalidate(6, maximize = $$props.maximize);
		if ('inline' in $$props) $$invalidate(7, inline = $$props.inline);
		if ('indented' in $$props) $$invalidate(8, indented = $$props.indented);
		if ('fading' in $$props) $$invalidate(11, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(18, i18n = $$props.i18n);
		if ('$$scope' in $$props) $$invalidate(21, $$scope = $$props.$$scope);
	};

	return [
		elements,
		addButton,
		sortable,
		removable,
		label,
		disabled,
		maximize,
		inline,
		indented,
		style,
		icon,
		fading,
		nodeInputId,
		addHandler,
		removeHandler,
		id,
		node,
		height,
		i18n,
		slots,
		click_handler,
		$$scope
	];
}

class EditableList extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal,
			{
				id: 15,
				node: 16,
				elements: 0,
				addButton: 1,
				sortable: 2,
				removable: 3,
				height: 17,
				style: 9,
				icon: 10,
				label: 4,
				disabled: 5,
				maximize: 6,
				inline: 7,
				indented: 8,
				fading: 11,
				i18n: 18
			},
			add_css$3
		);
	}
}

/* ../svelte-integration-red/components/Select.svelte generated by Svelte v3.42.4 */

function add_css$2(target) {
	append_styles(target, "svelte-msdd66", ".disabled.svelte-msdd66{pointer-events:none}.maximize.svelte-msdd66{width:100%}.sir-input select, .sir-select select{padding-left:3px}.sir-select{display:inline-flex;width:100%;align-items:center}");
}

// (50:2) {#if label}
function create_if_block$2(ctx) {
	let label_1;
	let t0;
	let t1;
	let label_1_for_value;
	let if_block = /*icon*/ ctx[8] && create_if_block_1$2(ctx);

	return {
		c() {
			label_1 = element("label");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(/*label*/ ctx[3]);
			attr(label_1, "for", label_1_for_value = "node-input-" + /*id*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t0);
			append(label_1, t1);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[8]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$2(ctx);
					if_block.c();
					if_block.m(label_1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*label*/ 8) set_data(t1, /*label*/ ctx[3]);

			if (dirty & /*id*/ 16 && label_1_for_value !== (label_1_for_value = "node-input-" + /*id*/ ctx[4])) {
				attr(label_1, "for", label_1_for_value);
			}
		},
		d(detaching) {
			if (detaching) detach(label_1);
			if (if_block) if_block.d();
		}
	};
}

// (51:33) {#if icon}
function create_if_block_1$2(ctx) {
	let i;
	let i_class_value;

	return {
		c() {
			i = element("i");
			attr(i, "class", i_class_value = "fa fa-" + /*icon*/ ctx[8] + " svelte-msdd66");
		},
		m(target, anchor) {
			insert(target, i, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 256 && i_class_value !== (i_class_value = "fa fa-" + /*icon*/ ctx[8] + " svelte-msdd66")) {
				attr(i, "class", i_class_value);
			}
		},
		d(detaching) {
			if (detaching) detach(i);
		}
	};
}

// (49:0) <Row clazz="sir-select" {inline} {fading}>
function create_default_slot$2(ctx) {
	let t;
	let select;
	let select_id_value;
	let select_placeholder_value;
	let current;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[3] && create_if_block$2(ctx);
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			select = element("select");
			if (default_slot) default_slot.c();
			attr(select, "id", select_id_value = "node-input-" + /*id*/ ctx[4]);
			select.disabled = /*disabled*/ ctx[5];
			attr(select, "placeholder", select_placeholder_value = /*node*/ ctx[1] && /*defaults*/ ctx[10][/*prop*/ ctx[7]].label || '');
			attr(select, "class", "svelte-msdd66");
			if (/*value*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[16].call(select));
			toggle_class(select, "maximize", /*maximize*/ ctx[6]);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*value*/ ctx[0]);
			current = true;

			if (!mounted) {
				dispose = [
					listen(select, "change", /*select_change_handler*/ ctx[16]),
					listen(select, "mouseenter", /*mouseenter_handler*/ ctx[14]),
					listen(select, "mouseleave", /*mouseleave_handler*/ ctx[15])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[17],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 16 && select_id_value !== (select_id_value = "node-input-" + /*id*/ ctx[4])) {
				attr(select, "id", select_id_value);
			}

			if (!current || dirty & /*disabled*/ 32) {
				select.disabled = /*disabled*/ ctx[5];
			}

			if (!current || dirty & /*node, prop*/ 130 && select_placeholder_value !== (select_placeholder_value = /*node*/ ctx[1] && /*defaults*/ ctx[10][/*prop*/ ctx[7]].label || '')) {
				attr(select, "placeholder", select_placeholder_value);
			}

			if (dirty & /*value*/ 1) {
				select_option(select, /*value*/ ctx[0]);
			}

			if (dirty & /*maximize*/ 64) {
				toggle_class(select, "maximize", /*maximize*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach(t);
			if (detaching) detach(select);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$2(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				clazz: "sir-select",
				inline: /*inline*/ ctx[2],
				fading: /*fading*/ ctx[9],
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(row.$$.fragment);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};
			if (dirty & /*inline*/ 4) row_changes.inline = /*inline*/ ctx[2];
			if (dirty & /*fading*/ 512) row_changes.fading = /*fading*/ ctx[9];

			if (dirty & /*$$scope, id, disabled, node, prop, value, maximize, label, icon*/ 131579) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { node, inline = false, prop, value, icon, label, id, disabled = false, maximize = true, fading = true, i18n } = $$props;

	if (!id) {
		id = getId(prop);
	}

	inline = getBooleanFrom(inline);
	disabled = getBooleanFrom(disabled);
	maximize = getBooleanFrom(maximize);
	const dispatch = createEventDispatcher();
	const updateNode = typeof node !== 'undefined';
	value = updateNode && node[prop] || value;
	let init = true;
	let defaults = node ? node._def.defaults : {};
	if (label !== false) label = label || node && (defaults[prop] && defaults[prop].label || prop);

	if (label) {
		label = i18nTranslate(RED, node, i18n, label);
	}

	function mouseenter_handler(event) {
		bubble.call(this, $$self, event);
	}

	function mouseleave_handler(event) {
		bubble.call(this, $$self, event);
	}

	function select_change_handler() {
		value = select_value(this);
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(1, node = $$props.node);
		if ('inline' in $$props) $$invalidate(2, inline = $$props.inline);
		if ('prop' in $$props) $$invalidate(7, prop = $$props.prop);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('icon' in $$props) $$invalidate(8, icon = $$props.icon);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('id' in $$props) $$invalidate(4, id = $$props.id);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ('maximize' in $$props) $$invalidate(6, maximize = $$props.maximize);
		if ('fading' in $$props) $$invalidate(9, fading = $$props.fading);
		if ('i18n' in $$props) $$invalidate(11, i18n = $$props.i18n);
		if ('$$scope' in $$props) $$invalidate(17, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*prop, value, init*/ 4225) {
			{
				if (updateNode) {
					$$invalidate(1, node[prop] = value, node);
				}

				if (!init) {
					dispatch('change', { value });
				}

				$$invalidate(12, init = false);
			}
		}
	};

	return [
		value,
		node,
		inline,
		label,
		id,
		disabled,
		maximize,
		prop,
		icon,
		fading,
		defaults,
		i18n,
		init,
		slots,
		mouseenter_handler,
		mouseleave_handler,
		select_change_handler,
		$$scope
	];
}

class Select extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$2,
			create_fragment$2,
			safe_not_equal,
			{
				node: 1,
				inline: 2,
				prop: 7,
				value: 0,
				icon: 8,
				label: 3,
				id: 4,
				disabled: 5,
				maximize: 6,
				fading: 9,
				i18n: 11
			},
			add_css$2
		);
	}
}

async function getApiList() {
  const url = encodeURI('https://www.linode.com/docs/api/openapi.yaml');
  // server call
  return window.$.get('getNewOpenApiInfo?openApiUrl=' + url, function (response) {
    return response
  })
    .fail(function (message) {
      return message
    })
}

const getCorrectType = (param) => {
  const type = param?.schema?.type || param.type;
  if (type === 'boolean') return 'bool'
  if (type === 'integer') return 'num'
  if (param.name === 'Json Request Body' || param.name === 'body' || type === 'body' || type === 'object') return 'json'
  if (param?.items?.enum?.length > 0 || param?.schema?.enum?.length) return 'array'
  return 'str'
};

const getAllowedTypes = (input) => {
  let type;
  if (typeof input === 'string') type = input;
  else type = getCorrectType(input);
  if (type === 'bool') return ['bool', 'msg', 'flow', 'global']
  if (type === 'num') return ['num', 'jsonata', 'msg', 'flow', 'global']
  if (type === 'json') return ['json', 'jsonata', 'msg', 'flow', 'global']
  if (type === 'array') {
    const options = input?.items?.enum || input?.schema?.enum;
    return [{ value: 'select', label: 'Select', options: options }, 'str', 'msg', 'flow', 'global']
  }
  return ['str', 'json', 'jsonata', 'msg', 'flow', 'global']
};

// is an object
const sortKeys = (schema) => {
  let keys = null;
  if (schema?.properties) {
    // ordering keys helps later with svelte #each (first required then normal and sorted alphabetical)
    keys = Object.keys(schema.properties).sort();
    if (schema.required) {
      const notRequiredKeys = keys.filter(prop => !schema.required.includes(prop));
      keys = schema.required.sort().concat(notRequiredKeys.sort());
    }
  }
  return keys
};
// is an array
const orderRequired = (a, b) => {
  let comparison = 0;
  if (b.required) {
    comparison = 1;
  } else if (a.required) {
    comparison = -1;
  }
  return comparison
};

const createParameters = (node, operationData, oldParameters) => {
  // openApi 3 new body style with selection
  if (!operationData.parameters && operationData?.requestBody?.content) {
    const requestBody = operationData.requestBody;
    const content = requestBody.content;
    const keys = sortKeys(content[node.contentType].schema);
    if (content[node.contentType]) {
      node.parameters.push({
        id: 'requestBody',
        name: 'Request body',
        in: '',
        schema: content[node.contentType].schema || null,
        value: oldParameters?.[' Request body']?.value || '{}',
        required: !!requestBody?.required || false,
        isActive: !!requestBody?.required || oldParameters?.[' Request body']?.isActive || false,
        description: requestBody?.description || '-',
        type: oldParameters?.[' Request body']?.inputType || 'json',
        allowedTypes: getAllowedTypes('json'),
        keys
      });
    }
  } else {
    let parameters = operationData?.parameters?.sort(orderRequired);
    if (!parameters) parameters = [];
    parameters.forEach(param => {
      const keys = sortKeys(param.schema);
      node.parameters.push(
        {
          id: param.name + param.in,
          name: param.name,
          in: param.in,
          required: param.required,
          value: oldParameters?.[param.name + ' ' + param.in]?.value || '',
          isActive: !!param.required || oldParameters?.[param.name + ' ' + param.in]?.isActive || false,
          type: oldParameters?.[param.name + ' ' + param.in]?.inputType || getCorrectType(param), // selected type
          allowedTypes: getAllowedTypes(param),
          description: param.description || '-',
          schema: param.schema || null,
          keys
        }
      );
    });
  }
};

/* utils/JsonParamHelper.svelte generated by Svelte v3.42.4 */

function add_css$1(target) {
	append_styles(target, "svelte-qzpchp", ".jsonObjectKeyList.svelte-qzpchp{margin-bottom:0px}.jsonKeys.svelte-qzpchp{display:none}");
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[8] = list[i];
	return child_ctx;
}

function get_each_context_2$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i][0];
	child_ctx[12] = list[i][1];
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i][0];
	child_ctx[12] = list[i][1];
	return child_ctx;
}

// (55:0) <Row>
function create_default_slot$1(ctx) {
	let button0;
	let t0;
	let button1;
	let t1;
	let button2;
	let current;

	button0 = new Button({
			props: { icon: "show", label: /*label*/ ctx[2] }
		});

	button0.$on("click", /*click_handler*/ ctx[4]);

	button1 = new Button({
			props: { icon: "edit", label: "Set default" }
		});

	button1.$on("click", /*click_handler_1*/ ctx[5]);

	button2 = new Button({
			props: { icon: "edit", label: "Set required" }
		});

	button2.$on("click", /*click_handler_2*/ ctx[6]);

	return {
		c() {
			create_component(button0.$$.fragment);
			t0 = space();
			create_component(button1.$$.fragment);
			t1 = space();
			create_component(button2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button0, target, anchor);
			insert(target, t0, anchor);
			mount_component(button1, target, anchor);
			insert(target, t1, anchor);
			mount_component(button2, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button0_changes = {};
			if (dirty & /*label*/ 4) button0_changes.label = /*label*/ ctx[2];
			button0.$set(button0_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(button2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(button2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach(t0);
			destroy_component(button1, detaching);
			if (detaching) detach(t1);
			destroy_component(button2, detaching);
		}
	};
}

// (99:2) {:else}
function create_else_block$1(ctx) {
	let t;

	return {
		c() {
			t = text("No properties defined.");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (61:2) {#if param.schema && param.keys}
function create_if_block$1(ctx) {
	let each_1_anchor;
	let each_value = /*param*/ ctx[0].keys;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*Object, param*/ 1) {
				each_value = /*param*/ ctx[0].keys;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (68:10) {#if param.schema.properties[propKey].description}
function create_if_block_5$1(ctx) {
	let div;
	let t0;
	let t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].description + "";
	let t1;

	return {
		c() {
			div = element("div");
			t0 = text("Description: ");
			t1 = text(t1_value);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*param*/ 1 && t1_value !== (t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].description + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (71:10) {#if param.schema.properties[propKey].example}
function create_if_block_4$1(ctx) {
	let div;
	let t0;
	let t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].example + "";
	let t1;

	return {
		c() {
			div = element("div");
			t0 = text("Example: ");
			t1 = text(t1_value);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*param*/ 1 && t1_value !== (t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].example + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (82:119) 
function create_if_block_2$1(ctx) {
	let div1;
	let div0;
	let t0;
	let t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.type + "";
	let t1;
	let t2;
	let if_block = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.type === "object" && /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]]?.items?.properties && create_if_block_3$1(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t0 = text("Containing: ");
			t1 = text(t1_value);
			t2 = space();
			if (if_block) if_block.c();
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, t0);
			append(div0, t1);
			append(div1, t2);
			if (if_block) if_block.m(div1, null);
		},
		p(ctx, dirty) {
			if (dirty & /*param*/ 1 && t1_value !== (t1_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.type + "")) set_data(t1, t1_value);

			if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.type === "object" && /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]]?.items?.properties) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3$1(ctx);
					if_block.c();
					if_block.m(div1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();
		}
	};
}

// (74:10) {#if param.schema.properties[propKey].type === "object"}
function create_if_block_1$1(ctx) {
	let t0_value = "{" + "";
	let t0;
	let t1;
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t2;
	let t3_value = "}" + "";
	let t3;
	let each_value_1 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].properties);
	const get_key = ctx => /*pKey*/ ctx[11];

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1(key, child_ctx));
	}

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			t3 = text(t3_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert(target, t2, anchor);
			insert(target, t3, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*Object, param*/ 1) {
				each_value_1 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].properties);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, ul, destroy_block, create_each_block_1$1, null, get_each_context_1$1);
			}
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach(t2);
			if (detaching) detach(t3);
		}
	};
}

// (85:14) {#if param.schema.properties[propKey].items.type === "object" && param.schema.properties[propKey]?.items?.properties}
function create_if_block_3$1(ctx) {
	let t0_value = "{" + "";
	let t0;
	let t1;
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t2;
	let t3_value = "}" + "";
	let t3;
	let each_value_2 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.properties);
	const get_key = ctx => /*pKey*/ ctx[11];

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2$1(ctx, each_value_2, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_2$1(key, child_ctx));
	}

	return {
		c() {
			t0 = text(t0_value);
			t1 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			t3 = text(t3_value);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert(target, t2, anchor);
			insert(target, t3, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*Object, param*/ 1) {
				each_value_2 = Object.entries(/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].items.properties);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, ul, destroy_block, create_each_block_2$1, null, get_each_context_2$1);
			}
		},
		d(detaching) {
			if (detaching) detach(t0);
			if (detaching) detach(t1);
			if (detaching) detach(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach(t2);
			if (detaching) detach(t3);
		}
	};
}

// (88:18) {#each Object.entries(param.schema.properties[propKey].items.properties) as [pKey, p] (pKey)}
function create_each_block_2$1(key_1, ctx) {
	let p;
	let t0_value = /*pKey*/ ctx[11] + "";
	let t0;
	let t1;
	let t2_value = /*p*/ ctx[12].type + "";
	let t2;

	return {
		key: key_1,
		first: null,
		c() {
			p = element("p");
			t0 = text(t0_value);
			t1 = text(": ");
			t2 = text(t2_value);
			attr(p, "class", "jsonObjectKeyList svelte-qzpchp");
			this.first = p;
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			append(p, t2);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*param*/ 1 && t0_value !== (t0_value = /*pKey*/ ctx[11] + "")) set_data(t0, t0_value);
			if (dirty & /*param*/ 1 && t2_value !== (t2_value = /*p*/ ctx[12].type + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (77:14) {#each Object.entries(param.schema.properties[propKey].properties) as [pKey, p] (pKey)}
function create_each_block_1$1(key_1, ctx) {
	let p;
	let t0_value = /*pKey*/ ctx[11] + "";
	let t0;
	let t1;
	let t2_value = /*p*/ ctx[12].type + "";
	let t2;

	return {
		key: key_1,
		first: null,
		c() {
			p = element("p");
			t0 = text(t0_value);
			t1 = text(": ");
			t2 = text(t2_value);
			attr(p, "class", "jsonObjectKeyList svelte-qzpchp");
			this.first = p;
		},
		m(target, anchor) {
			insert(target, p, anchor);
			append(p, t0);
			append(p, t1);
			append(p, t2);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*param*/ 1 && t0_value !== (t0_value = /*pKey*/ ctx[11] + "")) set_data(t0, t0_value);
			if (dirty & /*param*/ 1 && t2_value !== (t2_value = /*p*/ ctx[12].type + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) detach(p);
		}
	};
}

// (62:4) {#each param.keys as propKey}
function create_each_block$1(ctx) {
	let ul;
	let li;
	let div;
	let t0_value = /*propKey*/ ctx[8] + "";
	let t0;
	let t1;
	let t2_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].type + "";
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;

	function func(...args) {
		return /*func*/ ctx[7](/*propKey*/ ctx[8], ...args);
	}

	let if_block0 = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].description && create_if_block_5$1(ctx);
	let if_block1 = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].example && create_if_block_4$1(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].type === "object") return create_if_block_1$1;
		if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].type === "array" && /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]]?.items?.type) return create_if_block_2$1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block2 = current_block_type && current_block_type(ctx);

	return {
		c() {
			ul = element("ul");
			li = element("li");
			div = element("div");
			t0 = text(t0_value);
			t1 = text(": ");
			t2 = text(t2_value);
			t3 = space();
			if (if_block0) if_block0.c();
			t4 = space();
			if (if_block1) if_block1.c();
			t5 = space();
			if (if_block2) if_block2.c();
			t6 = space();
			toggle_class(div, "required", /*param*/ ctx[0].schema.required && /*param*/ ctx[0].schema.required.find(func));
		},
		m(target, anchor) {
			insert(target, ul, anchor);
			append(ul, li);
			append(li, div);
			append(div, t0);
			append(div, t1);
			append(div, t2);
			append(li, t3);
			if (if_block0) if_block0.m(li, null);
			append(li, t4);
			if (if_block1) if_block1.m(li, null);
			append(li, t5);
			if (if_block2) if_block2.m(li, null);
			append(ul, t6);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*param*/ 1 && t0_value !== (t0_value = /*propKey*/ ctx[8] + "")) set_data(t0, t0_value);
			if (dirty & /*param*/ 1 && t2_value !== (t2_value = /*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].type + "")) set_data(t2, t2_value);

			if (dirty & /*param*/ 1) {
				toggle_class(div, "required", /*param*/ ctx[0].schema.required && /*param*/ ctx[0].schema.required.find(func));
			}

			if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].description) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_5$1(ctx);
					if_block0.c();
					if_block0.m(li, t4);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*param*/ ctx[0].schema.properties[/*propKey*/ ctx[8]].example) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_4$1(ctx);
					if_block1.c();
					if_block1.m(li, t5);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block2) {
				if_block2.p(ctx, dirty);
			} else {
				if (if_block2) if_block2.d(1);
				if_block2 = current_block_type && current_block_type(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(li, null);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(ul);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();

			if (if_block2) {
				if_block2.d();
			}
		}
	};
}

function create_fragment$1(ctx) {
	let row;
	let t;
	let div;
	let current;

	row = new Row({
			props: {
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	function select_block_type(ctx, dirty) {
		if (/*param*/ ctx[0].schema && /*param*/ ctx[0].keys) return create_if_block$1;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			create_component(row.$$.fragment);
			t = space();
			div = element("div");
			if_block.c();
			attr(div, "class", "svelte-qzpchp");
			toggle_class(div, "jsonKeys", /*hideJsonKeys*/ ctx[1]);
		},
		m(target, anchor) {
			mount_component(row, target, anchor);
			insert(target, t, anchor);
			insert(target, div, anchor);
			if_block.m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			const row_changes = {};

			if (dirty & /*$$scope, param, label, hideJsonKeys*/ 131079) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}

			if (dirty & /*hideJsonKeys*/ 2) {
				toggle_class(div, "jsonKeys", /*hideJsonKeys*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(row, detaching);
			if (detaching) detach(t);
			if (detaching) detach(div);
			if_block.d();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { param } = $$props;

	const setJsonKeys = (param, option) => {
		const required = [];
		const notRequired = [];
		const exists = [];
		const propKeys = Object.keys(param.schema.properties);
		let fieldValue = window.$('#node-input-' + param.id).typedInput('value');

		try {
			fieldValue = JSON.parse(fieldValue);
		} catch {
			fieldValue = {};
		}

		propKeys.forEach(prop => {
			if (fieldValue[prop]) {
				const value = fieldValue[prop];

				// chk if value is empty array or object -> would return "" otherwise
				if (typeof value === 'object') {
					if (Array.isArray(value) && value.length === 0) exists.push(`"${prop}": []`); else if (Object.keys(value).length === 0) exists.push(`"${prop}": {}`); else exists.push(`"${prop}": "${value}"`);
				} else {
					exists.push(`"${prop}": "${value}"`);
				}
			} else {
				let isRequired = false;
				if (param.schema.required) isRequired = param.schema.required.find(reqParam => reqParam === prop);

				if (isRequired) {
					required.push(`"${prop}": "${param.schema.properties[prop].type} - required"`);
				} else {
					notRequired.push(`"${prop}": "${param.schema.properties[prop].type}"`);
				}
			}
		});

		let result = required.concat(exists);
		if (option === 'default') result = result.concat(notRequired);
		result = '{' + result.join(', ') + '}';

		// jQuery because setting node.parameters[index].value does not work
		window.$('#node-input-' + param.id).typedInput('value', result);
	};

	let hideJsonKeys = true;
	let label = "Show Keys";
	const click_handler = () => $$invalidate(1, hideJsonKeys = !hideJsonKeys);
	const click_handler_1 = () => setJsonKeys(param, "default");
	const click_handler_2 = () => setJsonKeys(param, "required");
	const func = (propKey, reqParam) => reqParam === propKey;

	$$self.$$set = $$props => {
		if ('param' in $$props) $$invalidate(0, param = $$props.param);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*hideJsonKeys*/ 2) {
			if (hideJsonKeys) {
				$$invalidate(2, label = "Show Keys");
			} else {
				$$invalidate(2, label = "Hide Keys");
			}
		}
	};

	return [
		param,
		hideJsonKeys,
		label,
		setJsonKeys,
		click_handler,
		click_handler_1,
		click_handler_2,
		func
	];
}

class JsonParamHelper extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { param: 0 }, add_css$1);
	}
}

/* linode.svelte generated by Svelte v3.42.4 */

function add_css(target) {
	append_styles(target, "svelte-phs3h0", "#linode .required, #linode .required label{font-weight:bold !important}#linode .label{width:104px}#linode .parameterInput label{width:17px !important}#linode .red-ui-editableList-item-content div{margin-top:0px !important;margin-bottom:0px !important}#linode .red-ui-editableList-container{min-height:300px;height:100% !important;overflow-y:hidden !important}#linode .red-ui-editableList .red-ui-typedInput-container{width:90% !important}#linode .nodeError{color:red}");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[22] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[27] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i][0];
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	return child_ctx;
}

// (205:6) {:else}
function create_else_block_3(ctx) {
	let option;
	let t_value = /*api*/ ctx[33] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*api*/ ctx[33];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*apis*/ 8 && t_value !== (t_value = /*api*/ ctx[33] + "")) set_data(t, t_value);

			if (dirty[0] & /*apis*/ 8 && option_value_value !== (option_value_value = /*api*/ ctx[33])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (203:6) {#if node.api === api}
function create_if_block_5(ctx) {
	let option;
	let t_value = /*api*/ ctx[33] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*api*/ ctx[33];
			option.value = option.__value;
			option.selected = true;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*apis*/ 8 && t_value !== (t_value = /*api*/ ctx[33] + "")) set_data(t, t_value);

			if (dirty[0] & /*apis*/ 8 && option_value_value !== (option_value_value = /*api*/ ctx[33])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (202:4) {#each apis as api}
function create_each_block_3(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*node*/ ctx[0].api === /*api*/ ctx[33]) return create_if_block_5;
		return create_else_block_3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (200:2) <Select bind:node prop="api">
function create_default_slot_4(ctx) {
	let option;
	let t;
	let each_1_anchor;
	let each_value_3 = /*apis*/ ctx[3];
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	return {
		c() {
			option = element("option");
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			option.__value = "";
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			insert(target, t, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*apis, node*/ 9) {
				each_value_3 = /*apis*/ ctx[3];
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
			if (detaching) detach(t);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (218:8) {:else}
function create_else_block_2(ctx) {
	let option;
	let t_value = /*operations*/ ctx[5][/*key*/ ctx[30]].summary + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*operations*/ ctx[5][/*key*/ ctx[30]].operationId;
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*operations*/ 32 && t_value !== (t_value = /*operations*/ ctx[5][/*key*/ ctx[30]].summary + "")) set_data(t, t_value);

			if (dirty[0] & /*operations*/ 32 && option_value_value !== (option_value_value = /*operations*/ ctx[5][/*key*/ ctx[30]].operationId)) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (214:8) {#if node.operation === operations[key].operationId}
function create_if_block_4(ctx) {
	let option;
	let t_value = /*operations*/ ctx[5][/*key*/ ctx[30]].summary + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*operations*/ ctx[5][/*key*/ ctx[30]].operationId;
			option.value = option.__value;
			option.selected = true;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*operations*/ 32 && t_value !== (t_value = /*operations*/ ctx[5][/*key*/ ctx[30]].summary + "")) set_data(t, t_value);

			if (dirty[0] & /*operations*/ 32 && option_value_value !== (option_value_value = /*operations*/ ctx[5][/*key*/ ctx[30]].operationId)) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (213:6) {#each Object.entries(operations) as [key]}
function create_each_block_2(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*node*/ ctx[0].operation === /*operations*/ ctx[5][/*key*/ ctx[30]].operationId) return create_if_block_4;
		return create_else_block_2;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (211:4) <Select bind:node prop="operation">
function create_default_slot_3(ctx) {
	let option;
	let t;
	let each_1_anchor;
	let each_value_2 = Object.entries(/*operations*/ ctx[5]);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	return {
		c() {
			option = element("option");
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			option.__value = "";
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			insert(target, t, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*operations, node*/ 33) {
				each_value_2 = Object.entries(/*operations*/ ctx[5]);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
			if (detaching) detach(t);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (225:4) {#if { operationDescription }}
function create_if_block_3(ctx) {
	let div2;
	let div0;
	let t1;
	let div1;
	let t2;

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			div0.textContent = "Description";
			t1 = space();
			div1 = element("div");
			t2 = text(/*operationDescription*/ ctx[6]);
			attr(div0, "class", "label");
			set_style(div1, "width", "70%");
			set_style(div2, "display", "flex");
			set_style(div2, "margin-bottom", "12px");
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div2, t1);
			append(div2, div1);
			append(div1, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*operationDescription*/ 64) set_data(t2, /*operationDescription*/ ctx[6]);
		},
		d(detaching) {
			if (detaching) detach(div2);
		}
	};
}

// (237:6) {:else}
function create_else_block_1(ctx) {
	let option;
	let t_value = /*contentType*/ ctx[27] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*contentType*/ ctx[27];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*contentTypes*/ 2 && t_value !== (t_value = /*contentType*/ ctx[27] + "")) set_data(t, t_value);

			if (dirty[0] & /*contentTypes*/ 2 && option_value_value !== (option_value_value = /*contentType*/ ctx[27])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (235:6) {#if node.contentType === contentType}
function create_if_block_2(ctx) {
	let option;
	let t_value = /*contentType*/ ctx[27] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*contentType*/ ctx[27];
			option.value = option.__value;
			option.selected = true;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*contentTypes*/ 2 && t_value !== (t_value = /*contentType*/ ctx[27] + "")) set_data(t, t_value);

			if (dirty[0] & /*contentTypes*/ 2 && option_value_value !== (option_value_value = /*contentType*/ ctx[27])) {
				option.__value = option_value_value;
				option.value = option.__value;
			}
		},
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (234:4) {#each contentTypes as contentType}
function create_each_block_1(ctx) {
	let if_block_anchor;

	function select_block_type_2(ctx, dirty) {
		if (/*node*/ ctx[0].contentType === /*contentType*/ ctx[27]) return create_if_block_2;
		return create_else_block_1;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (233:2) <Select bind:node prop="contentType">
function create_default_slot_2(ctx) {
	let each_1_anchor;
	let each_value_1 = /*contentTypes*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*contentTypes, node*/ 3) {
				each_value_1 = /*contentTypes*/ ctx[1];
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

// (292:2) {:else}
function create_else_block(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			div.textContent = "No parameters found!";
			set_style(div, "margin-top", "30px");
			set_style(div, "font-weight", "bold");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (246:2) {#if node.parameters.length > 0}
function create_if_block(ctx) {
	let editablelist;
	let updating_elements;
	let current;

	function editablelist_elements_binding(value) {
		/*editablelist_elements_binding*/ ctx[18](value);
	}

	let editablelist_props = {
		$$slots: {
			default: [
				create_default_slot_1,
				({ element: param, index }) => ({ 25: param, 26: index }),
				({ element: param, index }) => [(param ? 33554432 : 0) | (index ? 67108864 : 0)]
			]
		},
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0].parameters !== void 0) {
		editablelist_props.elements = /*node*/ ctx[0].parameters;
	}

	editablelist = new EditableList({ props: editablelist_props });
	binding_callbacks.push(() => bind(editablelist, 'elements', editablelist_elements_binding));

	return {
		c() {
			create_component(editablelist.$$.fragment);
		},
		m(target, anchor) {
			mount_component(editablelist, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const editablelist_changes = {};

			if (dirty[0] & /*param, node*/ 33554433 | dirty[1] & /*$$scope*/ 32) {
				editablelist_changes.$$scope = { dirty, ctx };
			}

			if (!updating_elements && dirty[0] & /*node*/ 1) {
				updating_elements = true;
				editablelist_changes.elements = /*node*/ ctx[0].parameters;
				add_flush_callback(() => updating_elements = false);
			}

			editablelist.$set(editablelist_changes);
		},
		i(local) {
			if (current) return;
			transition_in(editablelist.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(editablelist.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(editablelist, detaching);
		}
	};
}

// (286:6) {#if param?.schema?.type === "object"}
function create_if_block_1(ctx) {
	let div;
	let jsonparamhelper;
	let current;
	jsonparamhelper = new JsonParamHelper({ props: { param: /*param*/ ctx[25] } });

	return {
		c() {
			div = element("div");
			create_component(jsonparamhelper.$$.fragment);
			set_style(div, "margin-left", "20px");
			set_style(div, "margin-top", "10px", 1);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(jsonparamhelper, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const jsonparamhelper_changes = {};
			if (dirty[0] & /*param*/ 33554432) jsonparamhelper_changes.param = /*param*/ ctx[25];
			jsonparamhelper.$set(jsonparamhelper_changes);
		},
		i(local) {
			if (current) return;
			transition_in(jsonparamhelper.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(jsonparamhelper.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			destroy_component(jsonparamhelper);
		}
	};
}

// (247:4) <EditableList bind:elements={node.parameters} let:element={param} let:index>
function create_default_slot_1(ctx) {
	let div1;
	let div0;
	let input;
	let t0;
	let div2;
	let typedinput;
	let t1;
	let if_block_anchor;
	let current;

	function change_handler(...args) {
		return /*change_handler*/ ctx[16](/*index*/ ctx[26], ...args);
	}

	input = new Input({
			props: {
				type: "checkbox",
				label: /*param*/ ctx[25].name + ": " + /*param*/ ctx[25].description,
				value: /*param*/ ctx[25].isActive,
				disabled: /*param*/ ctx[25].required
			}
		});

	input.$on("change", change_handler);

	function change_handler_1(...args) {
		return /*change_handler_1*/ ctx[17](/*index*/ ctx[26], /*param*/ ctx[25], ...args);
	}

	typedinput = new TypedInput({
			props: {
				label: " ",
				types: /*param*/ ctx[25].allowedTypes,
				type: /*param*/ ctx[25].type,
				value: /*param*/ ctx[25].value,
				id: /*param*/ ctx[25].id,
				disabled: !/*param*/ ctx[25].isActive
			}
		});

	typedinput.$on("change", change_handler_1);
	let if_block = /*param*/ ctx[25]?.schema?.type === "object" && create_if_block_1(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			create_component(input.$$.fragment);
			t0 = space();
			div2 = element("div");
			create_component(typedinput.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			set_style(div0, "min-width", "99px");
			set_style(div1, "display", "flex");
			toggle_class(div1, "required", /*param*/ ctx[25].required);
			attr(div2, "class", "parameterInput");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(input, div0, null);
			insert(target, t0, anchor);
			insert(target, div2, anchor);
			mount_component(typedinput, div2, null);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const input_changes = {};
			if (dirty[0] & /*param*/ 33554432) input_changes.label = /*param*/ ctx[25].name + ": " + /*param*/ ctx[25].description;
			if (dirty[0] & /*param*/ 33554432) input_changes.value = /*param*/ ctx[25].isActive;
			if (dirty[0] & /*param*/ 33554432) input_changes.disabled = /*param*/ ctx[25].required;
			input.$set(input_changes);

			if (dirty[0] & /*param*/ 33554432) {
				toggle_class(div1, "required", /*param*/ ctx[25].required);
			}

			const typedinput_changes = {};
			if (dirty[0] & /*param*/ 33554432) typedinput_changes.types = /*param*/ ctx[25].allowedTypes;
			if (dirty[0] & /*param*/ 33554432) typedinput_changes.type = /*param*/ ctx[25].type;
			if (dirty[0] & /*param*/ 33554432) typedinput_changes.value = /*param*/ ctx[25].value;
			if (dirty[0] & /*param*/ 33554432) typedinput_changes.id = /*param*/ ctx[25].id;
			if (dirty[0] & /*param*/ 33554432) typedinput_changes.disabled = !/*param*/ ctx[25].isActive;
			typedinput.$set(typedinput_changes);

			if (/*param*/ ctx[25]?.schema?.type === "object") {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*param*/ 33554432) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(input.$$.fragment, local);
			transition_in(typedinput.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(input.$$.fragment, local);
			transition_out(typedinput.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			destroy_component(input);
			if (detaching) detach(t0);
			if (detaching) detach(div2);
			destroy_component(typedinput);
			if (detaching) detach(t1);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (297:4) {#each errorHandlingOptions as eOption}
function create_each_block(ctx) {
	let option;
	let t_value = /*eOption*/ ctx[22] + "";
	let t;
	let option_value_value;

	return {
		c() {
			option = element("option");
			t = text(t_value);
			option.__value = option_value_value = /*eOption*/ ctx[22];
			option.value = option.__value;
		},
		m(target, anchor) {
			insert(target, option, anchor);
			append(option, t);
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(option);
		}
	};
}

// (296:2) <Select bind:node prop="errorHandling">
function create_default_slot(ctx) {
	let each_1_anchor;
	let each_value = /*errorHandlingOptions*/ ctx[8];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*errorHandlingOptions*/ 256) {
				each_value = /*errorHandlingOptions*/ ctx[8];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach(each_1_anchor);
		}
	};
}

function create_fragment(ctx) {
	let div4;
	let input0;
	let updating_node;
	let t0;
	let input1;
	let updating_node_1;
	let t1;
	let div0;
	let label;
	let input2;
	let t2;
	let t3;
	let div1;
	let t4;
	let t5;
	let hr0;
	let t6;
	let select0;
	let updating_node_2;
	let t7;
	let div2;
	let select1;
	let updating_node_3;
	let t8;
	let t9;
	let select2;
	let updating_node_4;
	let t10;
	let div3;
	let t14;
	let current_block_type_index;
	let if_block1;
	let t15;
	let hr1;
	let t16;
	let select3;
	let updating_node_5;
	let current;
	let mounted;
	let dispose;

	function input0_node_binding(value) {
		/*input0_node_binding*/ ctx[11](value);
	}

	let input0_props = { prop: "name", placeholder: "linode" };

	if (/*node*/ ctx[0] !== void 0) {
		input0_props.node = /*node*/ ctx[0];
	}

	input0 = new Input({ props: input0_props });
	binding_callbacks.push(() => bind(input0, 'node', input0_node_binding));

	function input1_node_binding(value) {
		/*input1_node_binding*/ ctx[12](value);
	}

	let input1_props = { prop: "container", placeholder: "linode" };

	if (/*node*/ ctx[0] !== void 0) {
		input1_props.node = /*node*/ ctx[0];
	}

	input1 = new Input({ props: input1_props });
	binding_callbacks.push(() => bind(input1, 'node', input1_node_binding));

	function select0_node_binding(value) {
		/*select0_node_binding*/ ctx[13](value);
	}

	let select0_props = {
		prop: "api",
		$$slots: { default: [create_default_slot_4] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select0_props.node = /*node*/ ctx[0];
	}

	select0 = new Select({ props: select0_props });
	binding_callbacks.push(() => bind(select0, 'node', select0_node_binding));

	function select1_node_binding(value) {
		/*select1_node_binding*/ ctx[14](value);
	}

	let select1_props = {
		prop: "operation",
		$$slots: { default: [create_default_slot_3] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select1_props.node = /*node*/ ctx[0];
	}

	select1 = new Select({ props: select1_props });
	binding_callbacks.push(() => bind(select1, 'node', select1_node_binding));

	let if_block0 = {
		operationDescription: /*operationDescription*/ ctx[6]
	} && create_if_block_3(ctx);

	function select2_node_binding(value) {
		/*select2_node_binding*/ ctx[15](value);
	}

	let select2_props = {
		prop: "contentType",
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select2_props.node = /*node*/ ctx[0];
	}

	select2 = new Select({ props: select2_props });
	binding_callbacks.push(() => bind(select2, 'node', select2_node_binding));
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (/*node*/ ctx[0].parameters.length > 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_3(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	function select3_node_binding(value) {
		/*select3_node_binding*/ ctx[19](value);
	}

	let select3_props = {
		prop: "errorHandling",
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*node*/ ctx[0] !== void 0) {
		select3_props.node = /*node*/ ctx[0];
	}

	select3 = new Select({ props: select3_props });
	binding_callbacks.push(() => bind(select3, 'node', select3_node_binding));

	return {
		c() {
			div4 = element("div");
			create_component(input0.$$.fragment);
			t0 = space();
			create_component(input1.$$.fragment);
			t1 = space();
			div0 = element("div");
			label = element("label");
			input2 = element("input");
			t2 = text("\n      Do you want to propagate API credentials?");
			t3 = space();
			div1 = element("div");
			t4 = text(/*error*/ ctx[2]);
			t5 = space();
			hr0 = element("hr");
			t6 = space();
			create_component(select0.$$.fragment);
			t7 = space();
			div2 = element("div");
			create_component(select1.$$.fragment);
			t8 = space();
			if (if_block0) if_block0.c();
			t9 = space();
			create_component(select2.$$.fragment);
			t10 = space();
			div3 = element("div");

			div3.innerHTML = `<span class="label">Parameters</span> 
    <span style="font-size: 10px;">(bold = required parameters)</span>`;

			t14 = space();
			if_block1.c();
			t15 = space();
			hr1 = element("hr");
			t16 = space();
			create_component(select3.$$.fragment);
			attr(input2, "type", "checkbox");
			attr(input2, "id", "node-input-propagate");
			set_style(input2, "display", "inline-block");
			set_style(input2, "width", "22px");
			set_style(input2, "vertical-align", "top");
			input2.checked = /*propagate*/ ctx[4];
			set_style(label, "margin-left", "100px");
			set_style(label, "width", "70%");
			attr(div0, "class", "form-row");
			attr(div1, "class", "nodeError");
			set_style(div3, "display", "flex");
			attr(div4, "id", "linode");
		},
		m(target, anchor) {
			insert(target, div4, anchor);
			mount_component(input0, div4, null);
			append(div4, t0);
			mount_component(input1, div4, null);
			append(div4, t1);
			append(div4, div0);
			append(div0, label);
			append(label, input2);
			append(label, t2);
			append(div4, t3);
			append(div4, div1);
			append(div1, t4);
			append(div4, t5);
			append(div4, hr0);
			append(div4, t6);
			mount_component(select0, div4, null);
			append(div4, t7);
			append(div4, div2);
			mount_component(select1, div2, null);
			append(div2, t8);
			if (if_block0) if_block0.m(div2, null);
			append(div4, t9);
			mount_component(select2, div4, null);
			append(div4, t10);
			append(div4, div3);
			append(div4, t14);
			if_blocks[current_block_type_index].m(div4, null);
			append(div4, t15);
			append(div4, hr1);
			append(div4, t16);
			mount_component(select3, div4, null);
			current = true;

			if (!mounted) {
				dispose = listen(div4, "load", /*createApi*/ ctx[7]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const input0_changes = {};

			if (!updating_node && dirty[0] & /*node*/ 1) {
				updating_node = true;
				input0_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node = false);
			}

			input0.$set(input0_changes);
			const input1_changes = {};

			if (!updating_node_1 && dirty[0] & /*node*/ 1) {
				updating_node_1 = true;
				input1_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_1 = false);
			}

			input1.$set(input1_changes);

			if (!current || dirty[0] & /*propagate*/ 16) {
				input2.checked = /*propagate*/ ctx[4];
			}

			if (!current || dirty[0] & /*error*/ 4) set_data(t4, /*error*/ ctx[2]);
			const select0_changes = {};

			if (dirty[0] & /*apis, node*/ 9 | dirty[1] & /*$$scope*/ 32) {
				select0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node_2 && dirty[0] & /*node*/ 1) {
				updating_node_2 = true;
				select0_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_2 = false);
			}

			select0.$set(select0_changes);
			const select1_changes = {};

			if (dirty[0] & /*operations, node*/ 33 | dirty[1] & /*$$scope*/ 32) {
				select1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node_3 && dirty[0] & /*node*/ 1) {
				updating_node_3 = true;
				select1_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_3 = false);
			}

			select1.$set(select1_changes);

			if ({
				operationDescription: /*operationDescription*/ ctx[6]
			}) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.m(div2, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			const select2_changes = {};

			if (dirty[0] & /*contentTypes, node*/ 3 | dirty[1] & /*$$scope*/ 32) {
				select2_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node_4 && dirty[0] & /*node*/ 1) {
				updating_node_4 = true;
				select2_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_4 = false);
			}

			select2.$set(select2_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				transition_in(if_block1, 1);
				if_block1.m(div4, t15);
			}

			const select3_changes = {};

			if (dirty[1] & /*$$scope*/ 32) {
				select3_changes.$$scope = { dirty, ctx };
			}

			if (!updating_node_5 && dirty[0] & /*node*/ 1) {
				updating_node_5 = true;
				select3_changes.node = /*node*/ ctx[0];
				add_flush_callback(() => updating_node_5 = false);
			}

			select3.$set(select3_changes);
		},
		i(local) {
			if (current) return;
			transition_in(input0.$$.fragment, local);
			transition_in(input1.$$.fragment, local);
			transition_in(select0.$$.fragment, local);
			transition_in(select1.$$.fragment, local);
			transition_in(select2.$$.fragment, local);
			transition_in(if_block1);
			transition_in(select3.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(input0.$$.fragment, local);
			transition_out(input1.$$.fragment, local);
			transition_out(select0.$$.fragment, local);
			transition_out(select1.$$.fragment, local);
			transition_out(select2.$$.fragment, local);
			transition_out(if_block1);
			transition_out(select3.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div4);
			destroy_component(input0);
			destroy_component(input1);
			destroy_component(select0);
			destroy_component(select1);
			if (if_block0) if_block0.d();
			destroy_component(select2);
			if_blocks[current_block_type_index].d();
			destroy_component(select3);
			mounted = false;
			dispose();
		}
	};
}

RED.nodes.registerType("linode", {
	category: "DevSecOps",
	color: "#fff",
	defaults: {
		name: { value: "", label: "Name" },
		container: { value: "", label: "Container" },
		propagate: { value: false },
		api: { value: "", label: "API tag" },
		operation: { value: "", label: "Operation" },
		operationData: { value: {} },
		errorHandling: { value: "", label: "Error handling" },
		parameters: {
			value: [],
			label: "Parameters",
			validate(parameters) {
				if (!parameters || !Array.isArray(parameters) || parameters.length === 0) {
					return true;
				} else {
					let isValid = true;

					parameters.forEach(p => {
						if (isValid && p.isActive) {
							if (p.required && p.value.trim() === "") isValid = false;

							// validation of typedinput only if element exists!
							if (isValid && window.$("#node-input-" + p.id).length) isValid = window.$("#node-input-" + p.id).typedInput("validate");
						}
					});

					return isValid;
				}
			}
		},
		contentType: { value: "", label: "Content Type" },
		outputs: { value: 1 }
	},
	inputs: 1,
	outputs: 1,
	icon: "linode.svg",
	label() {
		if (this.name) return this.name; else if (this.operation) return this.operation; else return "linode";
	},
	oneditprepare() {
		render(this);
	},
	oneditsave() {
		let clone = this.__clone;

		// Bugfix SIR? if name is empty it returns undefined which will make the node think it has changed
		if (typeof clone.name === "undefined") clone.name = "";

		if (typeof clone.container === "undefined") clone.container = "";
		if (typeof clone.propagate === "undefined") clone.propagate = false;
		if (clone.propagate) this._def.color = "#c02626"; else this._def.color = "#fff";

		// Workaround if JSON-Editor (ACE) was used -> more info in bottom code (on:change event for typedInput Parameters)
		if (clone.saveTypedInputAgain) {
			clone.saveTypedInputAgain.forEach(({ index, id }) => {
				clone.parameters[index].value = window.$("#node-input-" + id).typedInput("value");
			});
		}

		update(this);
	},
	oneditcancel() {
		revert(this);
	}
});

function instance($$self, $$props, $$invalidate) {
	let { node } = $$props;
	let apiList = {};
	let error = "";
	let apis = [];
	let propagate = false;
	if (node.propagate) propagate = node.propagate;
	let operations = {};
	let operationDescription = "-";
	let prevOperation;
	if (node.operation) prevOperation = node.operation.toString();
	node.saveTypedInputAgain = [];
	let contentTypes = [];
	let oldParameters = {};

	const setError = message => {
		$$invalidate(3, apis = []);
		$$invalidate(5, operations = {});
		$$invalidate(1, contentTypes = []);
		$$invalidate(2, error = message);
		return;
	};

	const createApi = async () => {
		try {
			$$invalidate(2, error = "");
			$$invalidate(9, apiList = await getApiList());

			// save old parameter objects (linode version <0.2) - changed from object to array objects
			if (!Array.isArray(node.parameters) && node.api && node.operation) {
				Object.assign(oldParameters, node.parameters);
				$$invalidate(0, node.parameters = [], node);
				$$invalidate(10, prevOperation = "");
				$$invalidate(0, node.operationData = apiList?.[node.api]?.[node.operation], node);
			}

			// if a string was returned it is a node error
			if (typeof apiList === "string") {
				setError(apiList);
			} else {
				$$invalidate(3, apis = Object.keys(apiList));
			}
		} catch(e) {
			setError(e);
		}
	};

	createApi();
	const errorHandlingOptions = ["Standard", "other output", "throw exception"];

	function input0_node_binding(value) {
		node = value;
		(((($$invalidate(0, node), $$invalidate(9, apiList)), $$invalidate(1, contentTypes)), $$invalidate(10, prevOperation)), $$invalidate(20, oldParameters));
	}

	function input1_node_binding(value) {
		node = value;
		(((($$invalidate(0, node), $$invalidate(9, apiList)), $$invalidate(1, contentTypes)), $$invalidate(10, prevOperation)), $$invalidate(20, oldParameters));
	}

	function select0_node_binding(value) {
		node = value;
		(((($$invalidate(0, node), $$invalidate(9, apiList)), $$invalidate(1, contentTypes)), $$invalidate(10, prevOperation)), $$invalidate(20, oldParameters));
	}

	function select1_node_binding(value) {
		node = value;
		(((($$invalidate(0, node), $$invalidate(9, apiList)), $$invalidate(1, contentTypes)), $$invalidate(10, prevOperation)), $$invalidate(20, oldParameters));
	}

	function select2_node_binding(value) {
		node = value;
		(((($$invalidate(0, node), $$invalidate(9, apiList)), $$invalidate(1, contentTypes)), $$invalidate(10, prevOperation)), $$invalidate(20, oldParameters));
	}

	const change_handler = (index, e) => $$invalidate(0, node.parameters[index].isActive = e.detail.value, node);

	const change_handler_1 = (index, param, e) => {
		// if JSON-Editor (ACE) is used, it will return '[object Object]' as value, but set the correct JSON in the input field.
		// This seems to be a bug which occurs to non default fields and SIR. As non default fields will not be saved automaticlly (and this is a correct behavior)
		// we must use a workaround and don't save the value with the on:change event but save it when the node will be closed.
		if (typeof e.detail.value !== "object" && e.detail.value.toString() !== "[object Object]") {
			$$invalidate(0, node.parameters[index].value = e.detail.value, node);
			$$invalidate(0, node.parameters[index].type = e.detail.type, node);
		} else {
			// within the change event window.$('#node-input-' + id).typedInput('value') would also return the wrong value
			node.saveTypedInputAgain.push({ index, id: param.id });
		}
	};

	function editablelist_elements_binding(value) {
		if ($$self.$$.not_equal(node.parameters, value)) {
			node.parameters = value;
			(((($$invalidate(0, node), $$invalidate(9, apiList)), $$invalidate(1, contentTypes)), $$invalidate(10, prevOperation)), $$invalidate(20, oldParameters));
		}
	}

	function select3_node_binding(value) {
		node = value;
		(((($$invalidate(0, node), $$invalidate(9, apiList)), $$invalidate(1, contentTypes)), $$invalidate(10, prevOperation)), $$invalidate(20, oldParameters));
	}

	$$self.$$set = $$props => {
		if ('node' in $$props) $$invalidate(0, node = $$props.node);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*node, apiList*/ 513) {
			// set valid operations if api is set
			if (node.api && apiList?.[node.api]) {
				$$invalidate(5, operations = apiList[node.api]);
				(((($$invalidate(0, node), $$invalidate(9, apiList)), $$invalidate(1, contentTypes)), $$invalidate(10, prevOperation)), $$invalidate(20, oldParameters));
			} else {
				$$invalidate(5, operations = {});
			}
		}

		if ($$self.$$.dirty[0] & /*node, apiList, contentTypes, prevOperation*/ 1539) {
			// create content type selection and parameter list
			if (node.operation) {
				$$invalidate(6, operationDescription = "-");

				if (apiList?.[node.api]?.[node.operation]?.description) {
					$$invalidate(6, operationDescription = apiList[node.api][node.operation].description);
				}

				// set valid content Types if operation is set
				if (apiList?.[node.api]?.[node.operation]?.requestBody?.content) {
					$$invalidate(1, contentTypes = Object.keys(apiList[node.api][node.operation].requestBody.content));
				} else {
					// needed input since an update from swagger.js
					$$invalidate(1, contentTypes = [
						"application/json",
						"application/x-www-form-urlencoded",
						"multipart/form-data"
					]);
				}

				if (!node.contentType || !contentTypes.includes(node.contentType)) {
					$$invalidate(0, node.contentType = contentTypes[0], node);
				}

				// clear parameters if operation has changed
				if (prevOperation !== node.operation) {
					node.parameters.splice(0, node.parameters.length);
					$$invalidate(10, prevOperation = node.operation);
					let operationData = apiList?.[node.api]?.[node.operation];
					if (!operationData) operationData = {};
					$$invalidate(0, node.operationData = operationData, node);
					createParameters(node, operationData, oldParameters);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*node*/ 1) {
			if (node.errorHandling) {
				if ("other output" === node.errorHandling) $$invalidate(0, node.outputs = 2, node); else $$invalidate(0, node.outputs = 1, node);
			}
		}
	};

	return [
		node,
		contentTypes,
		error,
		apis,
		propagate,
		operations,
		operationDescription,
		createApi,
		errorHandlingOptions,
		apiList,
		prevOperation,
		input0_node_binding,
		input1_node_binding,
		select0_node_binding,
		select1_node_binding,
		select2_node_binding,
		change_handler,
		change_handler_1,
		editablelist_elements_binding,
		select3_node_binding
	];
}

class Linode extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { node: 0 }, add_css, [-1, -1]);
	}
}



              }
            </script>
            <script type="text/x-red" data-template-name="linode">
              <div id='linode-svelte-container'></div>
            </script>
            <script type="text/x-red" data-help-name="linode">
                <p>Use Linode API to provides the ability to programmatically manage the full range of Linode products and services.</p>

<p>It is based on <a href="https://www.linode.com/docs/api">Linode API v4.102.0</a> and <a href="https://github.com/swagger-api/swagger-js">swagger-js</a>.</p>

<h3>Inputs</h3>
    <dl class="message-properties">
        <dt>Name
            <span class="property-type">string</span>
        </dt>
        <dd> set a manuell name for the node. If no name is set, the node sets the selected operation name.</dd>
        <dt>Container
            <span class="property-type">string</span>
        </dt>
        <dd>The name of the container that will receive the Linode API object.</dd>
        <dt>API tag
            <span class="property-type">enum</span>
        </dt>
        <dd> Preselector for the operation. Grouped by the 'tags' in each operation. </dd>
        <dt>Operation
            <span class="property-type">enum</span>
        </dt>
        <dd> Selector for the OpenAPI operation. The selection name is set by the 'summary'. Behind the selector field is the (unique) operation id. By mouse-over it will show the full operation Description.</dd>
        <dt class="optional">Parameters <span class="property-type">depending</span></dt>
        <dd> If the selected operation has parameters, they will be listed here. The description can be found by mouse-over the parameter name. If the parameter is required, it will be marked with a red star behind the name.
            For Json Objects with defined keys there will be 3 Buttons: 'set required' and 'set default' will build a json-object with the correct key names and the necessary type info as the value. 'show keys' show all possible key parameters with additional info by mouse-over the key name.</dd>
    </dl>

    <h3>Outputs</h3>
    <dl class="message-properties">
    <dt>Container <span class="property-type">object</span>
        <dd> Returns the complete Linode API object.</dd>
    </dt>
    </dl>

<h3>Authentification</h3>
    For authentification you can use the Node-Red to get your token. This token has to be set into msg.access_token.

<h3>Error handling</h3>
This handles how to react if the server returns a http status of 4xx or 5xx. You can find the last server response in msg.response.
<dl class="message-properties">
    <dt>Standard  <span class="property-type">string</span> </dt>
    <dd> The flow will move on normally so you can choose how to handle this within your flow.</dd>
    <dt> Other output <span class="property-type">string</span></dt>
    <dd> The flow will move on in a second output.</dd>
    <dt> Throw exception <span class="property-type">string</span></dt>
    <dd> The flow will throw an exception. This exception can be catched by the 'catch' node.</dd>
</dl>

<h3>References</h3>
    <ul>
        <li><a href="https://www.npmjs.com/package/swagger-client">Based on npm swagger-client</a> - which does almost all the magic here</li>
        <li><a href="https://gitlab.com/2WeltenChris/svelte-integration-red">SIR</a> - Node designed with svelte</li>
        <li><a href="https://github.com/caputomarcos/node-red-contrib-linode">GitHub</a> - the nodes github repository</li>
    </ul>

            </script>
        